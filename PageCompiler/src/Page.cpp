//
// Page.cpp
//
// $Id: //poco/Main/PageCompiler/src/Page.cpp#1 $
//
// Copyright (c) 2007, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Page.h"
#include "Poco/FileStream.h"
#include "Poco/CountingStream.h"
#include "Poco/Path.h"
#include "Poco/Exception.h"
#include <sstream>
#include <cctype>


const std::string Page::MARKUP_BEGIN("\tostr << \"");
const std::string Page::MARKUP_END("\";\n");
const std::string Page::EXPR_BEGIN("\tostr << ");
const std::string Page::EXPR_END(";\n");


Page::Page(const std::string& basePath)
{
	_headerDecls.reserve(4096);
	_implDecls.reserve(8192);
	_paths.push_back(basePath);
}


Page::~Page()
{
}


void Page::addHeaderDecls(const std::string& decls)
{
	_headerDecls.append("\n");
	_headerDecls.append(decls);
}


void Page::addImplDecls(const std::string& decls)
{
	_implDecls.append("\n");
	_implDecls.append(decls);
}


void Page::addAttrs(const std::string& attrs)
{
	_attrs.append(attrs);
}


void Page::parse(std::istream& pageStream)
{
	std::ostringstream handlerStream;
	parse(pageStream, handlerStream);
	_handler = handlerStream.str();
}


void Page::parse(std::istream& pageStream, std::ostream& handlerStream)
{
	ParsingState state = STATE_MARKUP;

	_attrs.clear();
	handlerStream << MARKUP_BEGIN;

	Poco::CountingInputStream countingPageStream(pageStream);
	std::string token;
	nextToken(pageStream, token);
	while (!token.empty())
	{
		if (token == "<%")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				state = STATE_BLOCK;
			}
			else handlerStream << token;
		}
		else if (token == "<%!")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				state = STATE_IMPLDECL;
			}
			else handlerStream << token;
		}
		else if (token == "<%!!")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				state = STATE_HDRDECL;
			}
			else handlerStream << token;
		}
		else if (token == "<%--")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				state = STATE_COMMENT;
			}
			else handlerStream << token;
		}
		else if (token == "<%@")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				state = STATE_ATTR;
			}
			else handlerStream << token;
		}
		else if (token == "<%=")
		{
			if (state == STATE_MARKUP)
			{
				handlerStream << MARKUP_END;
				handlerStream << EXPR_BEGIN;
				state = STATE_EXPR;
			}
			else handlerStream << token;
		}
		else if (token == "%>")
		{
			if (state == STATE_EXPR)
			{
				handlerStream << EXPR_END;
				handlerStream << MARKUP_BEGIN;
				state = STATE_MARKUP;
			}
			else if (state == STATE_ATTR)
			{
				parseAttributes(handlerStream);
				_attrs.clear();
				handlerStream << MARKUP_BEGIN;
				state = STATE_MARKUP;
			}
			else if (state != STATE_MARKUP)
			{
				handlerStream << MARKUP_BEGIN;
				state = STATE_MARKUP;
			}
			else handlerStream << token;
		}
		else
		{
			switch (state)
			{
			case STATE_MARKUP:
				if (token == "\n")
				{
					handlerStream << "\\n";
					handlerStream << MARKUP_END;
					handlerStream << MARKUP_BEGIN;
				}
				else if (token == "\t")
				{
					handlerStream << "\\t";
				}
				else if (token == "\"")
				{
					handlerStream << "\\\"";
				}
				else if (token != "\r")
				{
					handlerStream << token;
				}
				break;
			case STATE_IMPLDECL:
				_implDecls += token;
				break;
			case STATE_HDRDECL:
				_headerDecls += token;
				break;
			case STATE_BLOCK:
				handlerStream << token;
				break;
			case STATE_EXPR:
				handlerStream << token;
				break;
			case STATE_COMMENT:
				break;
			case STATE_ATTR:
				_attrs += token;
				break;
			}
		}
		nextToken(pageStream, token);
	}

	if (state == STATE_MARKUP)
	{
		handlerStream << MARKUP_END;
	}
	else throw Poco::SyntaxException("unclosed meta or code block", where());
}


void Page::parseAttributes(std::ostream& handlerStream)
{
	static const int eof = std::char_traits<char>::eof();

	std::string basename;
	std::istringstream istr(_attrs);
	int ch = istr.get();
	while (ch != eof && std::isspace(ch)) ch = istr.get();
	while (ch != eof && std::isalnum(ch)) { basename += (char) ch; ch = istr.get(); }
	while (ch != eof && std::isspace(ch)) ch = istr.get();
	while (ch != eof)
	{
		std::string name(basename + ".");
		std::string value;
		while (ch != eof && std::isalnum(ch)) { name += (char) ch; ch = istr.get(); }
		while (ch != eof && std::isspace(ch)) ch = istr.get();
		if (ch != '=') throw Poco::SyntaxException("bad attribute syntax: '=' expected", where());
		ch = istr.get();
		while (ch != eof && std::isspace(ch)) ch = istr.get();
		if (ch != '"') throw Poco::SyntaxException("bad attribute syntax: '\"' expected", where());
		ch = istr.get();
		while (ch != eof && ch != '"') { value += (char) ch; ch = istr.get(); }
		if (ch != '"') throw Poco::SyntaxException("bad attribute syntax: '\"' expected", where());
		ch = istr.get();
		handleAttribute(name, value, handlerStream);
		while (ch != eof && std::isspace(ch)) ch = istr.get();
	}
}


void Page::nextToken(std::istream& istr, std::string& token)
{
	token.clear();
	int ch = istr.get();
	if (ch != -1)
	{
		if (ch == '<' && istr.peek() == '%')
		{
			token += "<%";
			ch = istr.get();
			ch = istr.peek();
			switch (ch)
			{
			case '!':
				ch = istr.get();
				token += (char) ch;
				if (istr.peek() == '!')
				{
					ch = istr.get();
					token += (char) ch;
				}
				break;
			case '=':
				ch = istr.get();
				token += (char) ch;
				break;
			case '@':
				ch = istr.get();
				token += (char) ch;
				break;
			case '-':
				ch = istr.get();
				token += (char) ch;
				if (istr.peek() == '-')
				{
					ch = istr.get();
					token += (char) ch;
				}
				break;
			}
		}
		else if (ch == '%' && istr.peek() == '>')
		{
			token += "%>";
			ch = istr.get();
		}
		else token += (char) ch;
	}
}


void Page::handleAttribute(const std::string& name, const std::string& value, std::ostream& handlerStream)
{
	if (name == "include.page")
	{
		include(value, handlerStream);
	}
	else
	{
		set(name, value);
	}
}


void Page::include(const std::string& path, std::ostream& handlerStream)
{
	Poco::Path currentPath(_paths.back());
	Poco::Path includePath(path);
	currentPath.resolve(includePath);
	handlerStream << "\t// begin include " << currentPath.toString() << "\n";
	_paths.push_back(currentPath.toString());
	if (_paths.size() > 100) throw Poco::ApplicationException("Too many includes", where());
	Poco::FileInputStream includeStream(currentPath.toString());
	parse(includeStream, handlerStream);
	_paths.pop_back();
	handlerStream << "\t// end include " << currentPath.toString() << "\n";
}


std::string Page::where()
{
	std::string result("in file '");
	std::vector<std::string>::reverse_iterator it = _paths.rbegin();
	result += *it;
	result += "'";
	++it;
	while (it != _paths.rend())
	{
		result += "\n\tincluded from file ";
		result += "'";
		result += *it;
		result += "'";
		++it;
	}
	return result;
}
