//
// Any.h
//
// $Id: //poco/1.4/Foundation/include/Poco/Any.h#1 $
//
// Library: Foundation
// Package: Core
// Module:	Any
//
// Copyright Kevlin Henney, 2000, 2001, 2002. All rights reserved.
// Extracted from Boost 1.33.1 lib and adapted for poco: Peter Schojer/AppliedInformatics 2006-02-02
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#ifndef Foundation_Any_INCLUDED
#define Foundation_Any_INCLUDED


#include "Poco/Exception.h"
#include "Poco/MetaProgramming.h"
#include <algorithm>
#include <typeinfo>


namespace Poco {


class Any
	/// An Any class represents a general type and is capable of storing any type, supporting type-safe extraction
	/// of the internally stored data.
	///
	/// Code taken from the Boost 1.33.1 library. Original copyright by Kevlin Henney. Modified for Poco
	/// by Applied Informatics.
	///
	/// Modified for small object optimization support (optionally supported through conditional compilation)
	/// by Alex Fabijanic.
{

#ifndef POCO_NO_SOO

	union PH;

public:

	Any()
		/// Creates an empty any type.
	{
	}

	template<typename ValueType>
	Any(const ValueType & value)
		/// Creates an any which stores the init parameter inside.
		///
		/// Example: 
		///	 Any a(13); 
		///	 Any a(string("12345"));
	{
		construct(value);
	}

	Any(const Any& other)
		/// Copy constructor, works with both empty and initialized Any values.
	{
		if ((this != &other) && !other.empty())
			construct(other);
	}

	~Any()
		/// Destructor. If Any is locally held, calls Placeholder destructor;
		/// otherwise, deletes the placeholder from the heap.
	{
		if(!empty())
		{
			if(_placeholder.isLocal())
				content()->~Placeholder();
			else
				delete content();
		}
	}

	Any& swap(Any& other)
		/// Swaps the content of the two Anys.
		/// 
		/// When small object optimizaton is enabled,
		/// swap is only exception-safe when both (*this and
		/// other) objects are allocated on the heap.
	{
		if (this == &other) return *this;

		if (!_placeholder.isLocal() && !other._placeholder.isLocal())
		{
			std::swap(_placeholder.pHolder, other._placeholder.pHolder);
		}
		else
		{
			Any tmp(*this);
			if (_placeholder.isLocal()) this->~Any();
			construct(other);
			other = tmp;
		}

		return *this;
	}

	template<typename ValueType>
	Any & operator = (const ValueType& rhs)
		/// Assignment operator for all types != Any.
		///
		/// Example: 
		///   Any a = 13; 
		///   Any a = string("12345");
	{
		construct(rhs);
		return *this;
	}
	
	Any& operator = (const Any& rhs)
		/// Assignment operator for Any.
	{
		if ((this != &rhs) && !rhs.empty())
			construct(rhs);
		else if ((this != &rhs) && rhs.empty())
			_placeholder.erase();

		return *this;
	}
	
	bool empty() const
		/// Returns true if the Any is empty.
	{
		char buf[POCO_SMALL_OBJECT_SIZE] = { 0 };
		return 0 == std::memcmp(_placeholder.holder, buf, POCO_SMALL_OBJECT_SIZE);
	}
	
	const std::type_info & type() const
		/// Returns the type information of the stored content.
		/// If the Any is empty typeid(void) is returned.
		/// It is recommended to always query an Any for its type info before
		/// trying to extract data via an AnyCast/RefAnyCast.
	{
		return empty() ? typeid(void) : content()->type();
	}

private:

	class Placeholder
	{
	public:
	
		virtual ~Placeholder()
		{
		}

		virtual const std::type_info & type() const = 0;
		virtual void clone(Any::PH*) const = 0;
	};

	template<typename ValueType>
	class Holder : public Placeholder
	{
	public:
		Holder(const ValueType & value) : _held(value)
		{
		}

		virtual const std::type_info & type() const
		{
			return typeid(ValueType);
		}

		virtual void clone(Any::PH* pPlaceholder) const
		{
			if ((sizeof(Holder<ValueType>) <= POCO_SMALL_OBJECT_SIZE))
			{
				new ((Placeholder*) pPlaceholder->holder) Holder(_held);
				pPlaceholder->setLocal(true);
			}
			else
			{
				pPlaceholder->pHolder = new Holder(_held);
				pPlaceholder->setLocal(false);
			}
		}

		ValueType _held;

	private:
		Holder & operator = (const Holder &);
	};

	Placeholder* content() const
	{
		return _placeholder.content();
	}

	template<typename ValueType>
	void construct(const ValueType& value)
	{
		if (sizeof(Holder<ValueType>) <= POCO_SMALL_OBJECT_SIZE)
		{
			new (_placeholder.holder) Holder<ValueType>(value);
			_placeholder.setLocal(true);
		}
		else
		{
			_placeholder.pHolder = new Holder<ValueType>(value);
			_placeholder.setLocal(false);
		}
	}

	void construct(const Any& other)
	{
		if(!other.empty())
			other.content()->clone(&_placeholder);
		else
			_placeholder.erase();
	}

	union PH
		/// Placeholder union. If Holder<Type> fits into POCO_SMALL_OBJECT_SIZE
		/// bytes of storage, it will be placement-new-allocated into the local buffer
		/// (i.e. there will be no heap-allocation. The local buffer size is one byte
		/// larger - [POCO_SMALL_OBJECT_SIZE + 1], additional byte value indicating
		/// where the object was allocated (0 => heap, 1 => local).
	{
		PH ()
		{
			erase();
		}

		void erase()
		{
			std::memset(holder, 0, sizeof(PH));
		}

		bool isLocal() const
		{
			return holder[POCO_SMALL_OBJECT_SIZE] != 0;
		}

		void setLocal(bool local) const
		{
			holder[POCO_SMALL_OBJECT_SIZE] = local ? 1 : 0;
		}

		Placeholder* content() const
		{
			if(isLocal())
				return reinterpret_cast<Placeholder*>(&holder[0]);
			else
				return pHolder;
		}

		Placeholder*          pHolder;
		mutable unsigned char holder[POCO_SMALL_OBJECT_SIZE + 1];
	} _placeholder;


#else // if POCO_NO_SOO


public:
	Any(): _pHolder(0)
		/// Creates an empty any type.
	{
	}

	template <typename ValueType>
	Any(const ValueType& value):
		_pHolder(new Holder<ValueType>(value))
		/// Creates an any which stores the init parameter inside.
		///
		/// Example: 
		///	 Any a(13); 
		///	 Any a(string("12345"));
	{
	}

	Any(const Any& other):
		_pHolder(other._pHolder ? other._pHolder->clone() : 0)
		/// Copy constructor, works with both empty and initialized Any values.
	{
	}

	~Any()
	{
		delete _pHolder;
	}

	Any& swap(Any& rhs)
		/// Swaps the content of the two Anys.
	{
		std::swap(_pHolder, rhs._pHolder);
		return *this;
	}

	template <typename ValueType>
	Any& operator = (const ValueType& rhs)
		/// Assignment operator for all types != Any.
		///
		/// Example: 
		///   Any a = 13; 
		///   Any a = string("12345");
	{
		Any(rhs).swap(*this);
		return *this;
	}

	Any& operator = (const Any& rhs)
		/// Assignment operator for Any.
	{
		Any(rhs).swap(*this);
		return *this;
	}

	bool empty() const
		/// Returns true if the Any is empty.
	{
		return !_pHolder;
	}

	const std::type_info& type() const
		/// Returns the type information of the stored content.
		/// If the Any is empty typeid(void) is returned.
		/// It is recommended to always query an Any for its type info before
		/// trying to extract data via an AnyCast/RefAnyCast.
	{
		return _pHolder ? _pHolder->type() : typeid(void);
	}

private:
	class Placeholder
	{
	public:
		virtual ~Placeholder()
		{
		}

		virtual const std::type_info& type() const = 0;
		virtual Placeholder* clone() const = 0;
	};

	template <typename ValueType>
	class Holder: public Placeholder
	{
	public: 
		Holder(const ValueType& value):
			_held(value)
		{
		}

		virtual const std::type_info& type() const
		{
			return typeid(ValueType);
		}

		virtual Placeholder* clone() const
		{
			return new Holder(_held);
		}

		ValueType _held;

	private:
		Holder & operator=(const Holder &);
	};

	Placeholder* content() const
	{
		return _pHolder;
	}

private:
	Placeholder* _pHolder;

#endif // POCO_NO_SOO

	template <typename ValueType>
	friend ValueType* AnyCast(Any*);

	template <typename ValueType>
	friend ValueType* UnsafeAnyCast(Any*);

};


template <typename ValueType>
ValueType* AnyCast(Any* operand)
	/// AnyCast operator used to extract the ValueType from an Any*. Will return a pointer
	/// to the stored value. 
	///
	/// Example Usage: 
	///	 MyType* pTmp = AnyCast<MyType*>(pAny).
	/// Will return NULL if the cast fails, i.e. types don't match.
{
	return operand && operand->type() == typeid(ValueType)
				? &static_cast<Any::Holder<ValueType>*>(operand->content())->_held
				: 0;
}


template <typename ValueType>
const ValueType* AnyCast(const Any* operand)
	/// AnyCast operator used to extract a const ValueType pointer from an const Any*. Will return a const pointer
	/// to the stored value. 
	///
	/// Example Usage:
	///	 const MyType* pTmp = AnyCast<MyType*>(pAny).
	/// Will return NULL if the cast fails, i.e. types don't match.
{
	return AnyCast<ValueType>(const_cast<Any*>(operand));
}


template <typename ValueType>
ValueType AnyCast(const Any& operand)
	/// AnyCast operator used to extract a copy of the ValueType from an const Any&.
	///
	/// Example Usage: 
	///	 MyType tmp = AnyCast<MyType>(anAny).
	/// Will throw a BadCastException if the cast fails.
	/// Dont use an AnyCast in combination with references, i.e. MyType& tmp = ... or const MyType& = ...
	/// Some compilers will accept this code although a copy is returned. Use the RefAnyCast in
	/// these cases.
{
	typedef typename TypeWrapper<ValueType>::TYPE NonRef;

	return AnyCast<NonRef&>(const_cast<Any&>(operand));
}


template <typename ValueType>
ValueType AnyCast(Any& operand)
	/// AnyCast operator used to extract a copy of the ValueType from an Any&.
	///
	/// Example Usage: 
	///	 MyType tmp = AnyCast<MyType>(anAny).
	/// Will throw a BadCastException if the cast fails.
	/// Dont use an AnyCast in combination with references, i.e. MyType& tmp = ... or const MyType& tmp = ...
	/// Some compilers will accept this code although a copy is returned. Use the RefAnyCast in
	/// these cases.
{
	typedef typename TypeWrapper<ValueType>::TYPE NonRef;

	NonRef* result = AnyCast<NonRef>(&operand);
	if (!result) throw BadCastException("Failed to convert between Any types");
	return *result;
}


template <typename ValueType>
const ValueType& RefAnyCast(const Any & operand)
	/// AnyCast operator used to return a const reference to the internal data. 
	///
	/// Example Usage: 
	///	 const MyType& tmp = RefAnyCast<MyType>(anAny);
{
	ValueType* result = AnyCast<ValueType>(const_cast<Any*>(&operand));
	if (!result) throw BadCastException("RefAnyCast: Failed to convert between const Any types");
	return *result;
}


template <typename ValueType>
ValueType& RefAnyCast(Any& operand)
	/// AnyCast operator used to return a reference to the internal data.
	///
	/// Example Usage: 
	///	 MyType& tmp = RefAnyCast<MyType>(anAny);
{
	ValueType* result = AnyCast<ValueType>(&operand);
	if (!result) throw BadCastException("RefAnyCast: Failed to convert between Any types");
	return *result;
}


template <typename ValueType>
ValueType* UnsafeAnyCast(Any* operand)
	/// The "unsafe" versions of AnyCast are not part of the
	/// public interface and may be removed at any time. They are
	/// required where we know what type is stored in the any and can't
	/// use typeid() comparison, e.g., when our types may travel across
	/// different shared libraries.
{
	return &static_cast<Any::Holder<ValueType>*>(operand->content())->_held;
}


template <typename ValueType>
const ValueType* UnsafeAnyCast(const Any* operand)
	/// The "unsafe" versions of AnyCast are not part of the
	/// public interface and may be removed at any time. They are
	/// required where we know what type is stored in the any and can't
	/// use typeid() comparison, e.g., when our types may travel across
	/// different shared libraries.
{
	return AnyCast<ValueType>(const_cast<Any*>(operand));
}


} // namespace Poco


#endif
