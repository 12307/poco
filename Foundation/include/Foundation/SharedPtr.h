//
// SharedPtr.h
//
// $Id: //poco/1.1.0/Foundation/include/Foundation/SharedPtr.h#2 $
//
// Library: Foundation
// Package: Core
// Module:  SharedPtr
//
// Definition of the SharedPtr template class.
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#ifndef Foundation_SharedPtr_INCLUDED
#define Foundation_SharedPtr_INCLUDED


#ifndef Foundation_Foundation_INCLUDED
#include "Foundation/Foundation.h"
#endif
#ifndef Foundation_RefCountedObject_INCLUDED
#include "Foundation/RefCountedObject.h"
#endif
#ifndef Foundation_Exception_INCLUDED
#include "Foundation/Exception.h"
#endif
#ifndef STD_ALGORITHM_INCLUDED
#include <algorithm>
#define STD_ALGORITHM_INCLUDED
#endif


Foundation_BEGIN


template <class C>
class SmartHandle: public RefCountedObject
	/// The SmartHandle class is used internally by SharedPtr
	/// to manage the reference count of objects.
{
public:
	SmartHandle(): _ptr(0)
	{
	}
	
	SmartHandle(C* ptr): _ptr(ptr)
	{
	}

	inline C* ptr() const
	{
		return _ptr;
	}

	inline C* deref() const
	{
		if (_ptr)
			return _ptr;
		else
			throw NullPointerException();
	}

protected:
	~SmartHandle()
	{
		delete _ptr;
	}
	
private:
	C* _ptr;
};


template <class C>
class SharedPtr
	/// SharedPtr is a "smart" pointer for classes implementing
	/// reference counting based garbage collection.
	/// SharedPtr is thus similar to AutoPtr. Unlike the
	/// AutoPtr template, which can only be used with
	/// classes that support reference counting, SharedPtr
	/// can be used with any class. For this to work, a
	/// SharedPtr manages a reference count for the object
	/// it manages.
	/// 
	/// SharedPtr works in the following way:
	/// If an SharedPtr is assigned an ordinary pointer to
	/// an object (via the constructor or the assignment operator),
	/// it takes ownership of the object and the object's reference 
	/// count is initialized to one.
	/// If the SharedPtr is assigned another SharedPtr, the
	/// object's reference count is incremented by one.
	/// The destructor of SharedPtr decrements the object's
	/// reference count by one and deletes the object if the
	/// reference count reaches zero.
	/// SharedPtr supports dereferencing with both the ->
	/// and the * operator. An attempt to dereference a null
	/// SharedPtr results in a NullPointerException being thrown.
	/// SharedPtr also implements all relational operators.
{
public:
	typedef SmartHandle<C> Handle;
	
	SharedPtr(): _handle(new Handle)
	{
	}

	SharedPtr(C* ptr): _handle(new Handle(ptr))
	{
	}

	SharedPtr(const SharedPtr& ptr): _handle(ptr._handle)
	{
		_handle->duplicate();
	}

	~SharedPtr()
	{
		_handle->release();
	}

	SharedPtr& operator = (C* ptr)
	{
		if (get() != ptr)
		{
			_handle->release();
			_handle = new Handle(ptr);
		}
		return *this;
	}

	SharedPtr& operator = (const SharedPtr& ptr)
	{
		if (&ptr != this)
		{
			_handle->release();
			_handle = ptr._handle;
			_handle->duplicate();
		}
		return *this;
	}
	
	void swap(SharedPtr& ptr)
	{
		std::swap(_handle, ptr._handle);
	}

	C* operator -> ()
	{
		return _handle->deref();
	}

	const C* operator -> () const
	{
		return _handle->deref();
	}

	C& operator * ()
	{
		return *_handle->deref();
	}

	const C& operator * () const
	{
		return *_handle->deref();
	}

	C* get()
	{
		return _handle->ptr();
	}
	
	operator C* ()
	{
		return _handle->ptr();
	}
	
	operator const C* () const
	{
		return _handle->ptr();
	}

	const C* get() const
	{
		return _handle->ptr();
	}

	bool operator == (const SharedPtr& ptr) const
	{
		return get() == ptr.get();
	}

	bool operator == (const C* ptr) const
	{
		return get() == ptr;
	}

	bool operator == (C* ptr) const
	{
		return get() == ptr;
	}

	bool operator != (const SharedPtr& ptr) const
	{
		return get() != ptr.get();
	}

	bool operator != (const C* ptr) const
	{
		return get() != ptr;
	}

	bool operator != (C* ptr) const
	{
		return get() != ptr;
	}

	bool operator < (const SharedPtr& ptr) const
	{
		return get() < ptr.get();
	}

	bool operator < (const C* ptr) const
	{
		return get() < ptr;
	}

	bool operator < (C* ptr) const
	{
		return get() < ptr;
	}

	bool operator <= (const SharedPtr& ptr) const
	{
		return get() <= ptr.get();
	}

	bool operator <= (const C* ptr) const
	{
		return get() <= ptr;
	}

	bool operator <= (C* ptr) const
	{
		return get() <= ptr;
	}

	bool operator > (const SharedPtr& ptr) const
	{
		return get() > ptr.get();
	}

	bool operator > (const C* ptr) const
	{
		return get() > ptr;
	}

	bool operator > (C* ptr) const
	{
		return get() > ptr;
	}

	bool operator >= (const SharedPtr& ptr) const
	{
		return get() >= ptr.get();
	}

	bool operator >= (const C* ptr) const
	{
		return get() >= ptr;
	}

	bool operator >= (C* ptr) const
	{
		return get() >= ptr;
	}

private:
	Handle* _handle;
};


template <class C>
inline void swap(SharedPtr<C>& p1, SharedPtr<C>& p2)
{
	p1.swap(p2);
}


Foundation_END


#endif // Foundation_SharedPtr_INCLUDED
