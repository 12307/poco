//
// Binder.cpp
//
// $Id: //poco/Main/Data/ODBC/src/Binder.cpp#4 $
//
// Library: ODBC
// Package: ODBC
// Module:  Binder
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Data/ODBC/Binder.h"
#include "Poco/Data/ODBC/Utility.h"
#include "Poco/Data/BLOB.h"
#include "Poco/Data/ODBC/ODBCException.h"
#include "Poco/DateTime.h"
#include "Poco/Exception.h"
#include <sql.h>


namespace Poco {
namespace Data {
namespace ODBC {


Binder::Binder(const StatementHandle& rStmt,
	std::size_t maxFieldSize,
	Binder::ParameterBinding dataBinding,
	TypeInfo* pDataTypes):
	_rStmt(rStmt),
	_paramBinding(dataBinding),
	_pTypeInfo(pDataTypes),
	_paramSetSize(0),
	_maxFieldSize(maxFieldSize)
{
}


Binder::~Binder()
{
	LengthVec::iterator itLen = _lengthIndicator.begin();
	LengthVec::iterator itLenEnd = _lengthIndicator.end();
	for(; itLen != itLenEnd; ++itLen) delete *itLen;

	TimestampMap::iterator itTS = _timestamps.begin();
	TimestampMap::iterator itTSEnd = _timestamps.end();
	for(; itTS != itTSEnd; ++itTS) delete itTS->first;

	StringMap::iterator itStr = _strings.begin();
	StringMap::iterator itStrEnd = _strings.end();
	for(; itStr != itStrEnd; ++itStr) std::free(itStr->first);

	CharPtrVec::iterator itChr = _charPtrs.begin();
	CharPtrVec::iterator endChr = _charPtrs.end();
	for (; itChr != endChr; ++itChr) delete [] *itChr;
}


void Binder::freeMemory()
{
	LengthVec::iterator itLen = _lengthIndicator.begin();
	LengthVec::iterator itLenEnd = _lengthIndicator.end();
	for(; itLen != itLenEnd; ++itLen) delete *itLen;

	TimeMap::iterator itT = _times.begin();
	TimeMap::iterator itTEnd = _times.end();
	for(; itT != itTEnd; ++itT) delete itT->first;

	DateMap::iterator itD = _dates.begin();
	DateMap::iterator itDEnd = _dates.end();
	for(; itD != itDEnd; ++itD) delete itD->first;

	TimestampMap::iterator itTS = _timestamps.begin();
	TimestampMap::iterator itTSEnd = _timestamps.end();
	for(; itTS != itTSEnd; ++itTS) delete itTS->first;

	StringMap::iterator itStr = _strings.begin();
	StringMap::iterator itStrEnd = _strings.end();
	for(; itStr != itStrEnd; ++itStr) std::free(itStr->first);

	CharPtrVec::iterator itChr = _charPtrs.begin();
	CharPtrVec::iterator endChr = _charPtrs.end();
	for (; itChr != endChr; ++itChr) std::free(*itChr);

	BoolPtrVec::iterator itBool = _boolPtrs.begin();
	BoolPtrVec::iterator endBool = _boolPtrs.end();
	for (; itBool != endBool; ++itBool) delete [] *itBool;
}


void Binder::bind(std::size_t pos, const std::string& val, Direction dir)
{
	SQLPOINTER pVal = 0;
	SQLINTEGER size = (SQLINTEGER) val.size();

	if (isOutBound(dir))
	{
		getColumnOrParameterSize(pos, size);
		char* pChar = (char*) std::calloc(size, sizeof(char));
		pVal = (SQLPOINTER) pChar;
		_outParams.insert(ParamMap::value_type(pVal, size));
		_strings.insert(StringMap::value_type(pChar, const_cast<std::string*>(&val)));
	}
	else if (isInBound(dir))
	{
		pVal = (SQLPOINTER) val.c_str();
		_inParams.insert(ParamMap::value_type(pVal, size));
	}
	else
		throw InvalidArgumentException("Parameter must be [in] OR [out] bound.");

	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn = SQL_NTS;

	if (PB_AT_EXEC == _paramBinding)
		*pLenIn = SQL_LEN_DATA_AT_EXEC(size);

	_lengthIndicator.push_back(pLenIn);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_CHAR, 
		SQL_LONGVARCHAR, 
		(SQLUINTEGER) size,
		0,
		pVal, 
		(SQLINTEGER) size, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter(std::string)");
	}
}


void Binder::bind(std::size_t pos, const std::vector<std::string>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("String vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = 0;
	getColumnOrParameterSize(pos, size);
	poco_assert (size > 0);

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), SQL_NTS);
	}

	if (_charPtrs.size() <= pos)
		_charPtrs.resize(pos + 1, 0);

	_charPtrs[pos] = (char*) std::calloc(val.size() * size, sizeof(char));
	
	std::size_t strSize;
	std::size_t offset = 0;
	std::vector<std::string>::const_iterator it = val.begin();
	std::vector<std::string>::const_iterator end = val.end();
	for (; it != end; ++it)
	{
		strSize = it->size();
		if (strSize > size)	
			throw LengthExceededException("SQLBindParameter(std::vector<std::string>)");
		std::memcpy(_charPtrs[pos] + offset, it->c_str(), strSize);
		offset += size;
	}

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_CHAR, 
		SQL_LONGVARCHAR, 
		(SQLUINTEGER) size - 1,
		0,
		_charPtrs[pos], 
		(SQLINTEGER) size, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter(std::vector<std::string>)");
	}
}


void Binder::bind(std::size_t pos, const BLOB& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("BLOB parameter type can only be inbound.");

	SQLPOINTER pVal = (SQLPOINTER) val.rawContent();
	SQLINTEGER size = (SQLINTEGER) val.size();
		
	_inParams.insert(ParamMap::value_type(pVal, size));

	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn  = size;

	if (PB_AT_EXEC == _paramBinding)
		*pLenIn  = SQL_LEN_DATA_AT_EXEC(size);

	_lengthIndicator.push_back(pLenIn);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		SQL_PARAM_INPUT, 
		SQL_C_BINARY, 
		SQL_LONGVARBINARY, 
		(SQLUINTEGER) size,
		0,
		pVal, 
		(SQLINTEGER) size, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter(BLOB)");
	}
}


void Binder::bind(std::size_t pos, const std::vector<BLOB>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("BLOB vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = 0;
	getColumnOrParameterSize(pos, size);
	poco_assert (size > 0);

	if (size == _maxFieldSize)
	{
		std::size_t maxSize = 0;
		std::vector<BLOB>::const_iterator it = val.begin();
		std::vector<BLOB>::const_iterator end = val.end();
		for (; it != end; ++it)
		{
			std::size_t sz = it->size();
			if (sz < _maxFieldSize && sz > maxSize)
				maxSize = sz;
		}
		if (maxSize) size = maxSize;
	}

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), SQL_NTS);
	}

	if (_charPtrs.size() <= pos)
		_charPtrs.resize(pos + 1, 0);

	_charPtrs[pos] = (char*) std::calloc(val.size() * size, sizeof(char));
	poco_check_ptr (_charPtrs[pos]);

	std::size_t blobSize;
	std::size_t offset = 0;
	std::vector<BLOB>::const_iterator it = val.begin();
	std::vector<BLOB>::const_iterator end = val.end();
	for (; it != end; ++it)
	{
		blobSize = it->size();
		if (blobSize > size)	
			throw LengthExceededException("SQLBindParameter(std::vector<BLOB>)");
		std::memcpy(_charPtrs[pos] + offset, it->rawContent(), blobSize);
		offset += size;
	}

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		SQL_PARAM_INPUT, 
		SQL_C_BINARY, 
		SQL_LONGVARBINARY, 
		(SQLUINTEGER) size,
		0,
		_charPtrs[pos], 
		(SQLINTEGER) size, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter(std::vector<BLOB>)");
	}
}


void Binder::bind(std::size_t pos, const Date& val, Direction dir)
{
	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_DATE_STRUCT);
	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn  = size;

	_lengthIndicator.push_back(pLenIn);

	SQL_DATE_STRUCT* pDS = new SQL_DATE_STRUCT;
	Utility::dateSync(*pDS, val);
	
	_dates.insert(DateMap::value_type(pDS, const_cast<Date*>(&val)));

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_DATE, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_DATE, 
		SQL_DATE, 
		colSize,
		decDigits,
		(SQLPOINTER) pDS, 
		0, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter(Date)");
	}
}


void Binder::bind(std::size_t pos, const std::vector<Date>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("Date vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_DATE_STRUCT);

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), size);
	}

	if (_dateVec.size() <= pos) _dateVec.resize(pos + 1);
	Utility::dateSync(_dateVec[pos], val);

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_DATE, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_DATE, 
		SQL_DATE, 
		colSize,
		decDigits,
		(SQLPOINTER) &_dateVec[pos][0], 
		0, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter(Date[])");
	}
}


void Binder::bind(std::size_t pos, const Time& val, Direction dir)
{
	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_TIME_STRUCT);
	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn  = size;

	_lengthIndicator.push_back(pLenIn);

	SQL_TIME_STRUCT* pTS = new SQL_TIME_STRUCT;
	Utility::timeSync(*pTS, val);
	
	_times.insert(TimeMap::value_type(pTS, const_cast<Time*>(&val)));

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_TIME, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_TIME, 
		SQL_TIME, 
		colSize,
		decDigits,
		(SQLPOINTER) pTS, 
		0, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter(Time)");
	}
}


void Binder::bind(std::size_t pos, const std::vector<Time>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("Time vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_TIME_STRUCT);

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), size);
	}

	if (_timeVec.size() <= pos)	_timeVec.resize(pos + 1);
	Utility::timeSync(_timeVec[pos], val);

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_TIME, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_TIME, 
		SQL_TIME, 
		colSize,
		decDigits,
		(SQLPOINTER) &_timeVec[pos][0], 
		0, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter(Time[])");
	}
}


void Binder::bind(std::size_t pos, const Poco::DateTime& val, Direction dir)
{
	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_TIMESTAMP_STRUCT);
	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn  = size;

	_lengthIndicator.push_back(pLenIn);

	SQL_TIMESTAMP_STRUCT* pTS = new SQL_TIMESTAMP_STRUCT;
	Utility::dateTimeSync(*pTS, val);

	_timestamps.insert(TimestampMap::value_type(pTS, const_cast<DateTime*>(&val)));

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_TIMESTAMP, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_TIMESTAMP, 
		SQL_TIMESTAMP, 
		colSize,
		decDigits,
		(SQLPOINTER) pTS, 
		0, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter(DateTime)");
	}
}


void Binder::bind(std::size_t pos, const std::vector<DateTime>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("DateTime vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = (SQLINTEGER) sizeof(SQL_TIMESTAMP_STRUCT);

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), size);
	}

	if (_dateTimeVec.size() <= pos)	_dateTimeVec.resize(pos + 1);
	Utility::dateTimeSync(_dateTimeVec[pos], val);

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_TIME, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		SQL_C_TIMESTAMP, 
		SQL_TIMESTAMP, 
		colSize,
		decDigits,
		(SQLPOINTER) &_dateTimeVec[pos][0], 
		0, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter(Time[])");
	}
}


void Binder::bind(std::size_t pos, const NullData& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("NULL parameter type can only be inbound.");

	_inParams.insert(ParamMap::value_type(0, 0));

	SQLLEN* pLenIn = new SQLLEN;
	*pLenIn  = SQL_NULL_DATA;

	_lengthIndicator.push_back(pLenIn);

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_C_STINYINT, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		SQL_PARAM_INPUT, 
		SQL_C_STINYINT, 
		Utility::sqlDataType(SQL_C_STINYINT), 
		colSize,
		decDigits,
		0, 
		0, 
		_lengthIndicator.back())))
	{
		throw StatementException(_rStmt, "SQLBindParameter()");
	}
}


void Binder::bind(std::size_t pos, const std::vector<NullData>& val, Direction dir)
{
	if (isOutBound(dir) || !isInBound(dir))
		throw NotImplementedException("DateTime vector parameter type can only be inbound.");

	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	if (0 == val.size())
		throw InvalidArgumentException("Empty vector not allowed.");

	setParamSetSize(pos, val.size());

	SQLINTEGER size = SQL_NULL_DATA;

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(val.size(), size);
	}

	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, SQL_TYPE_TIME, colSize, decDigits);

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		SQL_PARAM_INPUT, 
		SQL_C_STINYINT, 
		Utility::sqlDataType(SQL_C_STINYINT), 
		colSize,
		decDigits,
		0, 
		0, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter()");
	}
}


void Binder::bindImplVecBool(std::size_t pos, const std::vector<bool>& val, SQLSMALLINT cDataType, Direction dir)
{
	if (PB_IMMEDIATE != _paramBinding)
		throw InvalidAccessException("std::vector can only be bound immediately.");

	std::size_t length = val.size();
	SQLINTEGER colSize = 0;
	SQLSMALLINT decDigits = 0;
	getColSizeAndPrecision(pos, cDataType, colSize, decDigits);

	setParamSetSize(pos, val.size());

	if (_vecLengthIndicator.size() <= pos)
	{
		_vecLengthIndicator.resize(pos + 1);
		_vecLengthIndicator[pos].resize(length, sizeof(bool));
	}

	if (_boolPtrs.size() <= pos)
		_boolPtrs.resize(pos + 1);

	_boolPtrs[pos] = new bool[val.size()];

	std::vector<bool>::const_iterator it = val.begin();
	std::vector<bool>::const_iterator end = val.end();
	for (int i = 0; it != end; ++it, ++i) _boolPtrs[pos][i] = *it;

	if (Utility::isError(SQLBindParameter(_rStmt, 
		(SQLUSMALLINT) pos + 1, 
		toODBCDirection(dir), 
		cDataType, 
		Utility::sqlDataType(cDataType), 
		colSize,
		decDigits,
		(SQLPOINTER) &_boolPtrs[pos][0], 
		0, 
		&_vecLengthIndicator[pos][0])))
	{
		throw StatementException(_rStmt, "SQLBindParameter()");
	}
}


std::size_t Binder::parameterSize(SQLPOINTER pAddr) const
{
	ParamMap::const_iterator it = _inParams.find(pAddr);
	if (it != _inParams.end()) return it->second;

	it = _outParams.find(pAddr);
	if (it != _outParams.end()) return it->second;
	
	throw NotFoundException("Requested data size not found.");
}


void Binder::bind(std::size_t pos, const char* const &pVal, Direction dir)
{
	throw NotImplementedException("char* binding not implemented, Use std::string instead.");
}


SQLSMALLINT Binder::toODBCDirection(Direction dir) const
{
	bool in = isInBound(dir);
	bool out = isOutBound(dir);
	SQLSMALLINT ioType = SQL_PARAM_TYPE_UNKNOWN;
	if (in && out) ioType = SQL_PARAM_INPUT_OUTPUT; 
	else if(in)    ioType = SQL_PARAM_INPUT;
	else if(out)   ioType = SQL_PARAM_OUTPUT;
	else throw Poco::IllegalStateException("Binder not bound (must be [in] OR [out]).");

	return ioType;
}


void Binder::synchronize()
{
	if (_dates.size())
	{
		DateMap::iterator it = _dates.begin();
		DateMap::iterator end = _dates.end();
		for(; it != end; ++it) 
			Utility::dateSync(*it->second, *it->first);
	}

	if (_times.size())
	{
		TimeMap::iterator it = _times.begin();
		TimeMap::iterator end = _times.end();
		for(; it != end; ++it) 
			Utility::timeSync(*it->second, *it->first);
	}

	if (_timestamps.size())
	{
		TimestampMap::iterator it = _timestamps.begin();
		TimestampMap::iterator end = _timestamps.end();
		for(; it != end; ++it) 
			Utility::dateTimeSync(*it->second, *it->first);
	}

	if (_strings.size())
	{
		StringMap::iterator it = _strings.begin();
		StringMap::iterator end = _strings.end();
		for(; it != end; ++it)
			it->second->assign(it->first, strlen(it->first));
	}
}


void Binder::reset()
{
	freeMemory();
	LengthVec().swap(_lengthIndicator);
	_inParams.clear();
	_outParams.clear();
	_dates.clear();
	_times.clear();
	_timestamps.clear();
	_strings.clear();
	_dateVec.clear();
	_timeVec.clear();
	_dateTimeVec.clear();
	_charPtrs.clear();
	_boolPtrs.clear();
}


void Binder::getColSizeAndPrecision(std::size_t pos, 
	SQLSMALLINT cDataType, 
	SQLINTEGER& colSize, 
	SQLSMALLINT& decDigits)
{
	// Not all drivers are equally willing to cooperate in this matter.
	// Hence the funky flow control.
	try
	{
		if (_pTypeInfo)
		{
			colSize = _pTypeInfo->getInfo(cDataType, "COLUMN_SIZE");
			decDigits = _pTypeInfo->getInfo(cDataType, "MINIMUM_SCALE");
			return;
		}
	} catch (NotFoundException&) { }

	try
	{
		Parameter p(_rStmt, pos);
		colSize = (SQLINTEGER) p.columnSize();
		decDigits = (SQLSMALLINT) p.decimalDigits();
		return;
	} catch (StatementException&) { }

	try
	{
		ODBCColumn c(_rStmt, pos);
		colSize = (SQLINTEGER) c.length();
		decDigits = (SQLSMALLINT) c.precision();
		return;
	} catch (StatementException&) { }

	// no success, set to zero and hope for the best
	// (most drivers do not require these most of the times anyway)
	colSize = 0;
	decDigits = 0;
	return;
}


void Binder::getColumnOrParameterSize(std::size_t pos, SQLINTEGER& size)
{
	std::size_t colSize = 0;
	std::size_t paramSize = 0;

	try
	{
		ODBCColumn col(_rStmt, pos);
		colSize = col.length();
	}
	catch (StatementException&) { }

	try
	{
		Parameter p(_rStmt, pos);
		paramSize = p.columnSize();
	}
	catch (StatementException&)
	{
		size = DEFAULT_PARAM_SIZE;
//On Linux, PostgreSQL driver segfaults on SQLGetDescField, so this is disabled for now
#ifdef POCO_OS_FAMILY_WINDOWS
		SQLHDESC hIPD = 0;
		if (!Utility::isError(SQLGetStmtAttr(_rStmt, SQL_ATTR_IMP_PARAM_DESC, &hIPD, SQL_IS_POINTER, 0)))
		{
			SQLUINTEGER sz = 0;
			if (!Utility::isError(SQLGetDescField(hIPD, (SQLSMALLINT) pos + 1, SQL_DESC_LENGTH, &sz, SQL_IS_UINTEGER, 0)) && 
				sz > 0)
			{
				size = sz;
			}
		}
#endif
	}

	if (colSize > 0 && paramSize > 0)
		size = colSize < paramSize ? colSize : paramSize;
	else if (colSize > 0)
		size = colSize;
	else if (paramSize > 0)
		size = paramSize;

	if (size > _maxFieldSize) size = _maxFieldSize;
}


void Binder::setParamSetSize(std::size_t pos, std::size_t length)
{
	if (0 == _paramSetSize)
	{
		if (Utility::isError(SQLSetStmtAttr(_rStmt, SQL_ATTR_PARAM_BIND_TYPE, SQL_PARAM_BIND_BY_COLUMN, SQL_IS_UINTEGER)) ||  
			Utility::isError(SQLSetStmtAttr(_rStmt, SQL_ATTR_PARAMSET_SIZE, (SQLPOINTER) length, SQL_IS_UINTEGER)))
				throw StatementException(_rStmt, "SQLSetStmtAttr()");

		if (Utility::isError(SQLGetStmtAttr(_rStmt, SQL_ATTR_PARAMSET_SIZE, &_paramSetSize, 0, 0)))
			throw StatementException(_rStmt, "SQLGetStmtAttr()");
	}

	if (_paramSetSize != length)
		throw InvalidArgumentException("Invalid parameter array length.");
}


} } } // namespace Poco::Data::ODBC
