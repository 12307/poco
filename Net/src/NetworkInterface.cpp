//
// NetworkInterface.cpp
//
// $Id: //poco/1.4/Net/src/NetworkInterface.cpp#9 $
//
// Library: Net
// Package: Sockets
// Module:  NetworkInterface
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute ,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Net/NetworkInterface.h"
#include "Poco/Net/DatagramSocket.h"
#include "Poco/Net/NetException.h"
#include "Poco/NumberFormatter.h"
#include "Poco/RefCountedObject.h"
#if defined(_WIN32)
#if defined(POCO_WIN32_UTF8)
#include "Poco/UnicodeConverter.h"
#endif
#include <iphlpapi.h>
#include <ipifcons.h>
#endif
#include <cstring>


using Poco::NumberFormatter;
using Poco::FastMutex;


namespace Poco {
namespace Net {


//
// NetworkInterfaceImpl
//


class NetworkInterfaceImpl: public Poco::RefCountedObject
{
public:
	NetworkInterfaceImpl();
	NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, int index = -1);
	NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index = -1);

	int index() const;		
	const std::string& name() const;
	const std::string& displayName() const;
	const IPAddress& address() const;
	const IPAddress& subnetMask() const;
	const IPAddress& broadcastAddress() const;
	const IPAddress& destAddress() const;

	int mtu() const;
	int ifindex() const;
	bool broadcast() const;
	bool loopback() const;
	bool multicast() const;
	bool pointToPoint() const;
	bool running() const;
	bool up() const;

protected:
	~NetworkInterfaceImpl();

#if defined(_WIN32)
	void setFlags(DWORD flags, DWORD iftype);
#else
	void setFlags(short flags);
#endif

	void setMtu(int mtu)
	{
		_mtu = mtu;
	}

	void setIfIndex(unsigned ifIndex)
	{
		_ifindex = ifIndex;
	}

	void getPhyParams();

	void getIPv4Params();

	void getPeerAddress();

private:	
	std::string _name;
	std::string _displayName;
	IPAddress   _address;
	IPAddress   _subnetMask;
	IPAddress   _broadcastAddress;
	IPAddress   _destAddress;
	int         _index;

	bool        _broadcast;
	bool        _loopback;
	bool        _multicast;
	bool        _pointToPoint;
	bool        _up;
	bool        _running;
	int         _mtu;
	int         _ifindex;

#if defined(_WIN32)
	friend NetworkInterface::NetworkInterfaceList NetworkInterface::list();
#endif

};


NetworkInterfaceImpl::NetworkInterfaceImpl():
	_index(-1),
	_mtu(-1),
	_ifindex(-1)
{
}


NetworkInterfaceImpl::NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, int index):
	_name(name),
	_displayName(displayName),
	_address(address),
	_index(index),
	_broadcast(false),
	_loopback(false),
	_multicast(false),
	_pointToPoint(false),
	_up(false),
	_running(false),
	_mtu(-1),
	_ifindex(-1)
{
	getPhyParams();
	// get remaining IPv4 params from kernel
	if (address.family() == IPAddress::IPv4)
		getIPv4Params();
	if (_pointToPoint)
		getPeerAddress();
}


NetworkInterfaceImpl::NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_name(name),
	_displayName(displayName),
	_address(address),
	_subnetMask(subnetMask),
	_broadcastAddress(broadcastAddress),
	_index(index),
	_broadcast(false),
	_loopback(false),
	_multicast(false),
	_pointToPoint(false),
	_up(false),
	_running(false),
	_mtu(-1),
	_ifindex(-1)
{
	getPhyParams();
	if (_pointToPoint)
		getPeerAddress();
}


void NetworkInterfaceImpl::getPhyParams()
{
#if !defined(_WIN32) && !defined(POCO_VXWORKS)
	const IPAddress::Family family = _address.family();
	struct ifreq ifr;
	std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
	DatagramSocket ds(family);

	ds.impl()->ioctl(SIOCGIFFLAGS, &ifr);
	setFlags(ifr.ifr_flags);

	ds.impl()->ioctl(SIOCGIFMTU, &ifr);
	setMtu(ifr.ifr_mtu);

#if POCO_OS == POCO_OS_MAC_OS_X
	setIfIndex(if_nametoindex(ifr.ifr_name));
#else
	ds.impl()->ioctl(SIOCGIFINDEX, &ifr);
	setIfIndex(ifr.ifr_ifindex);
#endif
#endif
}

void NetworkInterfaceImpl::getIPv4Params()
{
#if !defined(_WIN32) && !defined(POCO_VXWORKS)
	struct ifreq ifr;
	std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
	DatagramSocket ds(IPAddress::IPv4);

	if (!_loopback) {
		ds.impl()->ioctl(SIOCGIFNETMASK, &ifr);
		if (ifr.ifr_addr.sa_family == AF_INET)
			_subnetMask = IPAddress(ifr.ifr_addr);
	}

	if (!_loopback && !_pointToPoint)
	{
		try
		{
			// Not every interface (e.g. loopback) has a broadcast address
			ds.impl()->ioctl(SIOCGIFBRDADDR, &ifr);
			if (ifr.ifr_addr.sa_family == AF_INET)
				_broadcastAddress = IPAddress(ifr.ifr_addr);
		}
		catch (...)
		{
		}
	}
#endif
}

void NetworkInterfaceImpl::getPeerAddress()
{
#if !defined(_WIN32) && !defined(POCO_VXWORKS)
	const IPAddress::Family family = _address.family();
	struct ifreq ifr;
	std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
	DatagramSocket ds(family);

	ds.impl()->ioctl(SIOCGIFDSTADDR, &ifr);
	if (ifr.ifr_dstaddr.sa_family == AF_INET)
		_destAddress = IPAddress(ifr.ifr_dstaddr);
	else
		_destAddress = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(&ifr.ifr_dstaddr)->sin6_addr, sizeof(struct in6_addr), _index);
#endif
}


NetworkInterfaceImpl::~NetworkInterfaceImpl()
{
}


inline int NetworkInterfaceImpl::index() const
{
	return _index;
}


inline const std::string& NetworkInterfaceImpl::name() const
{
	return _name;
}


inline const std::string& NetworkInterfaceImpl::displayName() const
{
	return _displayName;
}


inline const IPAddress& NetworkInterfaceImpl::address() const
{
	return _address;
}


inline const IPAddress& NetworkInterfaceImpl::subnetMask() const
{
	return _subnetMask;
}


inline const IPAddress& NetworkInterfaceImpl::broadcastAddress() const
{
	return _broadcastAddress;
}


inline const IPAddress& NetworkInterfaceImpl::destAddress() const
{
	return _destAddress;
}

inline int NetworkInterfaceImpl::mtu() const
{
	return _mtu;
}

inline int NetworkInterfaceImpl::ifindex() const
{
	return _ifindex;
}

inline bool NetworkInterfaceImpl::broadcast() const
{
	return _broadcast;
}

inline bool NetworkInterfaceImpl::loopback() const
{
	return _loopback;
}

inline bool NetworkInterfaceImpl::multicast() const
{
	return _multicast;
}

inline bool NetworkInterfaceImpl::pointToPoint() const
{
	return _pointToPoint;
}

inline bool NetworkInterfaceImpl::running() const
{
	return _running;
}

inline bool NetworkInterfaceImpl::up() const
{
	return _up;
}

#if defined(_WIN32)
void NetworkInterfaceImpl::setFlags(DWORD flags, DWORD iftype)
{
	// sigh...
	_running = _up = true;
	switch (iftype) {
	case IF_TYPE_ETHERNET_CSMACD:
	case IF_TYPE_ISO88025_TOKENRING:
	case IF_TYPE_IEEE80211:
		_multicast = _broadcast = true;
		break;
	case IF_TYPE_SOFTWARE_LOOPBACK:
		_loopback =  true;
		break;
	case IF_TYPE_PPP:
	case IF_TYPE_ATM:
	case IF_TYPE_TUNNEL:
	case IF_TYPE_IEEE1394:
		_pointToPoint = true;
		break;
	}
	if (!(flags & IP_ADAPTER_NO_MULTICAST))
		_multicast = true;
}
#else
void NetworkInterfaceImpl::setFlags(short flags)
{
#ifdef POCO_OS_FAMILY_UNIX
	_broadcast = ((flags & IFF_BROADCAST) != 0);
	_loopback = ((flags & IFF_LOOPBACK) != 0);
	_multicast = ((flags & IFF_MULTICAST) != 0);
	_pointToPoint = ((flags & IFF_POINTOPOINT) != 0);
	_running = ((flags & IFF_RUNNING) != 0);
	_up = ((flags & IFF_UP) != 0);
#endif
}
#endif


//
// NetworkInterface
//


FastMutex NetworkInterface::_mutex;


NetworkInterface::NetworkInterface():
	_pImpl(new NetworkInterfaceImpl)
{
}


NetworkInterface::NetworkInterface(const NetworkInterface& interfc):
	_pImpl(interfc._pImpl)
{
	_pImpl->duplicate();
}


NetworkInterface::NetworkInterface(const std::string& name, const std::string& displayName, const IPAddress& address, int index):
	_pImpl(new NetworkInterfaceImpl(name, displayName, address, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_pImpl(new NetworkInterfaceImpl(name, displayName, address, subnetMask, broadcastAddress, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const IPAddress& address, int index):
	_pImpl(new NetworkInterfaceImpl(name, name, address, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_pImpl(new NetworkInterfaceImpl(name, name, address, subnetMask, broadcastAddress, index))
{
}


NetworkInterface::~NetworkInterface()
{
	_pImpl->release();
}


NetworkInterface& NetworkInterface::operator = (const NetworkInterface& interfc)
{
	NetworkInterface tmp(interfc);
	swap(tmp);
	return *this;
}


void NetworkInterface::swap(NetworkInterface& other)
{
	using std::swap;
	swap(_pImpl, other._pImpl);
}


int NetworkInterface::index() const
{
	return _pImpl->index();
}


const std::string& NetworkInterface::name() const
{
	return _pImpl->name();
}


const std::string& NetworkInterface::displayName() const
{
	return _pImpl->displayName();
}


const IPAddress& NetworkInterface::address() const
{
	return _pImpl->address();
}


const IPAddress& NetworkInterface::subnetMask() const
{
	return _pImpl->subnetMask();
}


const IPAddress& NetworkInterface::broadcastAddress() const
{
	return _pImpl->broadcastAddress();
}


const IPAddress& NetworkInterface::destAddress() const
{
	return _pImpl->destAddress();
}

int NetworkInterface::mtu() const
{
	return _pImpl->mtu();
}

int NetworkInterface::ifindex() const
{
	return _pImpl->ifindex();
}


bool NetworkInterface::supportsIPv4() const
{
	return _pImpl->index() == -1;
}

	
bool NetworkInterface::supportsIPv6() const
{
	return _pImpl->index() != -1;
}


bool NetworkInterface::supportsBroadcast() const
{
	return _pImpl->broadcast();
}

bool NetworkInterface::supportsMulticast() const
{
	return _pImpl->multicast();
}

bool NetworkInterface::isLoopback() const
{
	return _pImpl->loopback();
}

bool NetworkInterface::isPointToPoint() const
{
	return _pImpl->pointToPoint();
}

bool NetworkInterface::isRunning() const
{
	return _pImpl->running();
}

bool NetworkInterface::isUp() const
{
	return _pImpl->up();
}


NetworkInterface NetworkInterface::forName(const std::string& name, bool requireIPv6)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->name() == name && ((requireIPv6 && it->supportsIPv6()) || !requireIPv6))
			return *it;
	}
	throw InterfaceNotFoundException(name);
}


NetworkInterface NetworkInterface::forName(const std::string& name, IPVersion ipVersion)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->name() == name)
		{
			if (ipVersion == IPv4_ONLY && it->supportsIPv4())
				return *it;
			else if (ipVersion == IPv6_ONLY && it->supportsIPv6())
				return *it;
			else if (ipVersion == IPv4_OR_IPv6)
				return *it;
		}
	}
	throw InterfaceNotFoundException(name);
}

	
NetworkInterface NetworkInterface::forAddress(const IPAddress& addr)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->address() == addr)
			return *it;
	}
	throw InterfaceNotFoundException(addr.toString());
}


NetworkInterface NetworkInterface::forIndex(int i)
{
	if (i != 0)
	{
		NetworkInterfaceList ifs = list();
		for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
		{
			if (it->index() == i)
				return *it;
		}
		throw InterfaceNotFoundException("#" + NumberFormatter::format(i));
	}
	else return NetworkInterface();
}


} } // namespace Poco::Net


//
// platform-specific code below
//


#if defined(POCO_OS_FAMILY_WINDOWS)
//
// Windows
//


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;
	DWORD rc;

#define GAA_FLAGS (GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_INCLUDE_PREFIX)
	const unsigned gaaFlags = GAA_FLAGS;

#if defined(POCO_HAVE_IPv6)
	const unsigned gaaFamily = AF_UNSPEC;
#else
	const unsigned gaaFamily = AF_INET;
#endif

	// On Windows XP/Server 2003 and later we use GetAdaptersAddresses.
	PIP_ADAPTER_ADDRESSES pAdapterAddresses;
	PIP_ADAPTER_ADDRESSES pAddress = 0;
	ULONG addrLen     = sizeof(IP_ADAPTER_ADDRESSES);
	pAdapterAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(new char[addrLen]);
	// Make an initial call to GetAdaptersAddresses to get
	// the necessary size into addrLen
	rc = GetAdaptersAddresses(gaaFamily, gaaFlags, 0, pAdapterAddresses, &addrLen);
	if (rc == ERROR_BUFFER_OVERFLOW) 
	{
		delete [] reinterpret_cast<char*>(pAdapterAddresses);
		pAdapterAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(new char[addrLen]);
	}
	else if (rc != ERROR_SUCCESS)
	{
		throw NetException("cannot get network adapter list");
	}
	try
	{
		if (GetAdaptersAddresses(gaaFamily, gaaFlags, 0, pAdapterAddresses, &addrLen) == NO_ERROR)
		{
			for (pAddress = pAdapterAddresses; pAddress; pAddress = pAddress->Next)
			{
				IPAddress address;
				IPAddress subnetMask;
				IPAddress broadcastAddress;
				unsigned ifIndex = ~0;

#if defined(POCO_HAVE_IPv6)
				if (pAddress->Flags & IP_ADAPTER_IPV6_ENABLED)
					ifIndex = pAddress->Ipv6IfIndex;
				else
#endif
				if (pAddress->Flags & IP_ADAPTER_IPV4_ENABLED)
					ifIndex = pAddress->IfIndex;

				IP_ADAPTER_PREFIX *pPrefix;
				unsigned i, prefixlen;
				for (i = 0, pPrefix = pAddress->FirstPrefix; pPrefix; pPrefix = pPrefix->Next, ++i)
				{
					switch (i) {
					case 0:
						prefixlen = pPrefix->PrefixLength;
						if (pPrefix->Address.lpSockaddr->sa_family == AF_INET)
							subnetMask = IPAddress(pPrefix->PrefixLength, IPAddress::IPv4);
#if defined(POCO_HAVE_IPv6)
						else
							subnetMask = IPAddress(pPrefix->PrefixLength, IPAddress::IPv6);
#endif
						break;
					case 1:
						address = IPAddress(pPrefix->Address);
						break;
					case 2:
						broadcastAddress = IPAddress(pPrefix->Address);
						break;
					case 3:
					case 4:
						// ignore multicast and broadcast prefixes
						break;
					}
				}

				if (pAddress->OperStatus == IfOperStatusUp)
				{
					PIP_ADAPTER_UNICAST_ADDRESS pUniAddr;
					for (pUniAddr = pAddress->FirstUnicastAddress; pUniAddr; pUniAddr = pUniAddr->Next)
					{
						std::string name(pAddress->AdapterName);
						std::string displayName;
#ifdef POCO_WIN32_UTF8
						Poco::UnicodeConverter::toUTF8(pAddress->FriendlyName, displayName);
#else
						char displayNameBuffer[1024];
						int rc = WideCharToMultiByte(CP_ACP, WC_DEFAULTCHAR, pAddress->FriendlyName, -1, displayNameBuffer, sizeof(displayNameBuffer), NULL, NULL);
						if (rc) displayName = displayNameBuffer;
#endif
						NetworkInterface* intf;
						switch (pUniAddr->Address.lpSockaddr->sa_family)
						{
						case AF_INET:
							address = IPAddress(pUniAddr->Address);
							result.push_back(NetworkInterface(name, displayName, address, subnetMask, broadcastAddress, -1));
							intf = &result.back();
							intf->_pImpl->setMtu(pAddress->Mtu);
							intf->_pImpl->setFlags(pAddress->Flags, pAddress->IfType);
							intf->_pImpl->setIfIndex(ifIndex); 
							break;
#if defined(POCO_HAVE_IPv6)
						case AF_INET6:
							address = IPAddress(pUniAddr->Address);
							result.push_back(NetworkInterface(name, displayName, address, pAddress->Ipv6IfIndex));
							intf = &result.back();
							intf->_pImpl->setMtu(pAddress->Mtu);
							intf->_pImpl->setFlags(pAddress->Flags, pAddress->IfType);
							intf->_pImpl->setIfIndex(ifIndex);
							break;
#endif // POCO_HAVE_IPv6
						}
					}
				}
			}
		}
		else throw NetException("cannot get network adapter list");
	}
	catch (Poco::Exception&)
	{
		delete [] reinterpret_cast<char*>(pAdapterAddresses);
		throw;
	}
	delete [] reinterpret_cast<char*>(pAdapterAddresses);
	return result;
}


} } // namespace Poco::Net


#elif defined(POCO_VXWORKS)
//
// VxWorks
//


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;

	int ifIndex = 1;
	char ifName[32];
	char ifAddr[INET_ADDR_LEN];

	for (;;)
	{
		if (ifIndexToIfName(ifIndex, ifName) == OK)
		{
			std::string name(ifName);
			IPAddress addr;
			IPAddress mask;
			IPAddress bcst;
			if (ifAddrGet(ifName, ifAddr) == OK)
			{			
				addr = IPAddress(std::string(ifAddr));
			}
			int ifMask;
			if (ifMaskGet(ifName, &ifMask) == OK)
			{
				mask = IPAddress(&ifMask, sizeof(ifMask));
			}
			if (ifBroadcastGet(ifName, ifAddr) == OK)
			{
				bcst = IPAddress(std::string(ifAddr));
			}
			result.push_back(NetworkInterface(name, name, addr, mask, bcst));
			ifIndex++;
		}
		else break;	
	}

	return result;
}


} } // namespace Poco::Net


#elif defined(POCO_OS_FAMILY_BSD) || POCO_OS == POCO_OS_QNX
//
// BSD variants
//
#include <sys/types.h>
#include <sys/socket.h>
#include <ifaddrs.h>
#include <net/if_dl.h>


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;

	struct ifaddrs* ifaphead;
	int rc = getifaddrs(&ifaphead);
	if (rc) throw NetException("cannot get network adapter list");

	for (struct ifaddrs* ifap = ifaphead; ifap; ifap = ifap->ifa_next) 
	{
		if (ifap->ifa_addr)
		{
			if (ifap->ifa_addr->sa_family == AF_INET)
			{
				std::string name(ifap->ifa_name);
				IPAddress addr(*(ifap->ifa_addr));
				IPAddress subnetMask, broadcastAddr;
				if (ifap->ifa_netmask)
					subnetMask = IPAddress(*(ifap->ifa_netmask));
				if ((ifap->ifa_flags & IFF_BROADCAST)
				  && ifap->ifa_broadaddr)
					broadcastAddr = IPAddress(*(ifap->ifa_broadaddr));
				result.push_back(NetworkInterface(name, name, addr, subnetMask, broadcastAddr));
			}
#if defined(POCO_HAVE_IPv6)
			else if (ifap->ifa_addr->sa_family == AF_INET6)
			{
				std::string name(ifap->ifa_name);
				Poco::UInt32 ifIndex = if_nametoindex(ifap->ifa_name);
				IPAddress addr(&reinterpret_cast<struct sockaddr_in6*>(ifap->ifa_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
				IPAddress subnetMask, broadcastAddr;
				if (ifap->ifa_netmask)
					subnetMask = IPAddress(*(ifap->ifa_netmask));
				if ((ifap->ifa_flags & IFF_BROADCAST)
				  && ifap->ifa_broadaddr)
					broadcastAddr = IPAddress(*(ifap->ifa_broadaddr));
				result.push_back(NetworkInterface(name, name, addr, subnetMask, broadcastAddr, ifIndex));
			}
#endif
		}
	}
	freeifaddrs(ifaphead);
	return result;
}


} } // namespace Poco::Net


#elif POCO_OS == POCO_OS_LINUX
//
// Linux
//
#if defined(POCO_HAVE_IPv6)


#include <sys/types.h>
#include <ifaddrs.h>


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	NetworkInterfaceList result;

	struct ifaddrs* ifaces = 0;
	struct ifaddrs* currIface = 0;

	if (getifaddrs(&ifaces) < 0) 
		throw NetException("cannot get network adapter list");
	
	try 
	{
		for (currIface = ifaces; currIface != 0; currIface = currIface->ifa_next) 
		{
			IPAddress addr;
			bool haveAddr = false;
			int ifIndex(-1);
			switch (currIface->ifa_addr->sa_family)
			{
			case AF_INET6:
				ifIndex = if_nametoindex(currIface->ifa_name);
				addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(currIface->ifa_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
				haveAddr = true;
				break;
			case AF_INET:
				addr = IPAddress(*(currIface->ifa_addr));
				haveAddr = true;
				break;
			default:
				break;
			}
			if (haveAddr) 
			{
				std::string name(currIface->ifa_name);
				result.push_back(NetworkInterface(name, name, addr, ifIndex));
			}
		}
	}
	catch (...) 
	{
	}
	if (ifaces) freeifaddrs(ifaces);

	return result;
}


} } // namespace Poco::Net


#else // !POCO_HAVE_IPv6


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;
	DatagramSocket socket;
	// the following code is loosely based
	// on W. Richard Stevens, UNIX Network Programming, pp 434ff.
	int lastlen = 0;
	int len = 100*sizeof(struct ifreq);
	char* buf = 0;
	try
	{
		struct ifconf ifc;
		for (;;)
		{
			buf = new char[len];
			ifc.ifc_len = len;
			ifc.ifc_buf = buf;
			if (::ioctl(socket.impl()->sockfd(), SIOCGIFCONF, &ifc) < 0)
			{
				if (errno != EINVAL || lastlen != 0)
					throw NetException("cannot get network adapter list");
			}
			else
			{
				if (ifc.ifc_len == lastlen)
					break;
				lastlen = ifc.ifc_len;
			}
			len += 10*sizeof(struct ifreq);
			delete [] buf;
		}
		for (const char* ptr = buf; ptr < buf + ifc.ifc_len;)
		{
			const struct ifreq* ifr = reinterpret_cast<const struct ifreq*>(ptr);
			IPAddress addr;
			bool haveAddr = false;
			switch (ifr->ifr_addr.sa_family)
			{
			case AF_INET:
				addr = IPAddress(ifr->ifr_addr);
				haveAddr = true;
				break;
			default:
				break;
			}
			if (haveAddr)
			{
				int index = -1;
				std::string name(ifr->ifr_name);
				result.push_back(NetworkInterface(name, name, addr, index));
			}
			ptr += sizeof(struct ifreq);
		}
	}
	catch (...)
	{
		delete [] buf;
		throw;
	}
	delete [] buf;
	return result;
}


} } // namespace Poco::Net


#endif // POCO_HAVE_IPv6


#else
//
// Non-BSD Unix variants
//


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;
	DatagramSocket socket;
	// the following code is loosely based
	// on W. Richard Stevens, UNIX Network Programming, pp 434ff.
	int lastlen = 0;
	int len = 100*sizeof(struct ifreq);
	char* buf = 0;
	try
	{
		struct ifconf ifc;
		for (;;)
		{
			buf = new char[len];
			ifc.ifc_len = len;
			ifc.ifc_buf = buf;
			if (::ioctl(socket.impl()->sockfd(), SIOCGIFCONF, &ifc) < 0)
			{
				if (errno != EINVAL || lastlen != 0)
					throw NetException("cannot get network adapter list");
			}
			else
			{
				if (ifc.ifc_len == lastlen)
					break;
				lastlen = ifc.ifc_len;
			}
			len += 10*sizeof(struct ifreq);
			delete [] buf;
		}
		for (const char* ptr = buf; ptr < buf + ifc.ifc_len;)
		{
			const struct ifreq* ifr = reinterpret_cast<const struct ifreq*>(ptr);
#if defined(POCO_HAVE_SALEN)
			len = ifr->ifr_addr.sa_len;
			if (sizeof(struct sockaddr) > len) len = sizeof(struct sockaddr);
#else
			len = sizeof(struct sockaddr);
#endif
			IPAddress addr;
			bool haveAddr = false;
			int ifIndex(-1);
			switch (ifr->ifr_addr.sa_family)
			{
#if defined(POCO_HAVE_IPv6)
			case AF_INET6:
				ifIndex = if_nametoindex(ifr->ifr_name);
				if (len < sizeof(struct sockaddr_in6)) len = sizeof(struct sockaddr_in6);
				addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(&ifr->ifr_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
				haveAddr = true;
				break;
#endif
			case AF_INET:
				if (len < sizeof(struct sockaddr_in)) len = sizeof(struct sockaddr_in);
				addr = IPAddress(ifr->ifr_addr);
				haveAddr = true;
				break;
			default:
				break;
			}
			if (haveAddr)
			{
				std::string name(ifr->ifr_name);
				result.push_back(NetworkInterface(name, name, addr, ifIndex));
			}
			len += sizeof(ifr->ifr_name);
			ptr += len;
		}
	}
	catch (...)
	{
		delete [] buf;
		throw;
	}
	delete [] buf;
	return result;
}


} } // namespace Poco::Net


#endif
