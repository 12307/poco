//
// NetworkInterface.cpp
//
// $Id: //poco/1.4/Net/src/NetworkInterface.cpp#9 $
//
// Library: Net
// Package: Sockets
// Module:  NetworkInterface
//
// Copyright (c) 2005-2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute ,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Net/NetworkInterface.h"
#include "Poco/Net/DatagramSocket.h"
#include "Poco/Net/NetException.h"
#include "Poco/NumberFormatter.h"
#include "Poco/RefCountedObject.h"
#include "Poco/Format.h"
#if defined(POCO_OS_FAMILY_WINDOWS)
#if defined(POCO_WIN32_UTF8)
#include "Poco/UnicodeConverter.h"
#endif
#include <iphlpapi.h>
#include <ipifcons.h>
#endif
#include <cstring>


using Poco::NumberFormatter;
using Poco::FastMutex;
using Poco::format;


namespace Poco {
namespace Net {


//
// NetworkInterfaceImpl
//


class NetworkInterfaceImpl: public Poco::RefCountedObject
{
public:
	typedef NetworkInterface::AddressTuple AddressTuple;
	typedef NetworkInterface::AddressList  AddressList;

	NetworkInterfaceImpl(int index = -1);
	NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, int index = -1);
	NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index = -1);

	int index() const;
	const std::string& name() const;
	const std::string& displayName() const;
	void addAddress(const AddressTuple& address);
	const IPAddress& address(std::size_t index = 0) const;
	const NetworkInterface::AddressList& addressList() const;
	bool hasAddress(const IPAddress& address) const;
	const IPAddress& subnetMask(std::size_t index = 0) const;
	const IPAddress& broadcastAddress(std::size_t index = 0) const;
	const IPAddress& destAddress(std::size_t index = 0) const;
	bool supportsIPv4() const;
	bool supportsIPv6() const;

	void setName(const std::string& name);
	void setDisplayName(const std::string& name);
	void addAddress(const IPAddress& addr);

	int mtu() const;
	int ifindex() const;
	bool broadcast() const;
	bool loopback() const;
	bool multicast() const;
	bool pointToPoint() const;
	bool running() const;
	bool up() const;

protected:
	~NetworkInterfaceImpl();

#if defined(POCO_OS_FAMILY_WINDOWS)
	void setFlags(DWORD flags, DWORD iftype);
#else
	void setFlags(short flags);
#endif

	void setUp(bool up);
	void setMtu(int mtu);
	void setIndex(std::size_t index);
	void getPhyParams();
	void getIPv4Params();
	void getPeerAddress();

private:	
	std::string     _name;
	std::string     _displayName;
	AddressList     _addressList;
	std::size_t     _index;
	bool            _broadcast;
	bool            _loopback;
	bool            _multicast;
	bool            _pointToPoint;
	bool            _up;
	bool            _running;
	int             _mtu;

#if defined(POCO_OS_FAMILY_WINDOWS)
	friend NetworkInterface::Map NetworkInterface::map();
#endif

};


NetworkInterfaceImpl::NetworkInterfaceImpl(int index):
	_index(index),
	_mtu(-1)
{
	_addressList.resize(1);
}


NetworkInterfaceImpl::NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, int index):
	_name(name),
	_displayName(displayName),
	_index(index),
	_broadcast(false),
	_loopback(false),
	_multicast(false),
	_pointToPoint(false),
	_up(false),
	_running(false),
	_mtu(-1)
{
	_addressList.push_back(AddressTuple(address, IPAddress(), IPAddress()));
	getPhyParams();
	// get remaining IPv4 params from kernel
	if (address.family() == IPAddress::IPv4) getIPv4Params();
	if (_pointToPoint) getPeerAddress();
}


NetworkInterfaceImpl::NetworkInterfaceImpl(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_name(name),
	_displayName(displayName),
	_index(index),
	_broadcast(false),
	_loopback(false),
	_multicast(false),
	_pointToPoint(false),
	_up(false),
	_running(false),
	_mtu(-1)
{
	_addressList.push_back(AddressTuple(address, subnetMask, broadcastAddress));
	getPhyParams();
	if (_pointToPoint) getPeerAddress();
}


void NetworkInterfaceImpl::getPhyParams()
{
#if !defined(POCO_OS_FAMILY_WINDOWS) && !defined(POCO_VXWORKS)
	const IPAddress::Family family = _addressList.family();
	struct ifreq ifr;
	std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
	DatagramSocket ds(family);

	ds.impl()->ioctl(SIOCGIFFLAGS, &ifr);
	setFlags(ifr.ifr_flags);

	ds.impl()->ioctl(SIOCGIFMTU, &ifr);
	setMtu(ifr.ifr_mtu);

	#if POCO_OS == POCO_OS_MAC_OS_X
		setIfIndex(if_nametoindex(ifr.ifr_name));
	#else
		ds.impl()->ioctl(SIOCGIFINDEX, &ifr);
		setIfIndex(ifr.ifr_ifindex);
	#endif
#endif
}


void NetworkInterfaceImpl::getIPv4Params()
{
#if !defined(POCO_OS_FAMILY_WINDOWS) && !defined(POCO_VXWORKS)
	struct ifreq ifr;
	std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
	DatagramSocket ds(IPAddress::IPv4);

	if (!_loopback) {
		ds.impl()->ioctl(SIOCGIFNETMASK, &ifr);
		if (ifr.ifr_addr.sa_family == AF_INET)
			_subnetMask = IPAddress(ifr.ifr_addr);
	}

	if (!_loopback && !_pointToPoint)
	{
		try
		{
			// Not every interface (e.g. loopback) has a broadcast address
			ds.impl()->ioctl(SIOCGIFBRDADDR, &ifr);
			if (ifr.ifr_addr.sa_family == AF_INET)
				_broadcastAddress = IPAddress(ifr.ifr_addr);
		}
		catch (...)
		{
		}
	}
#endif
}


void NetworkInterfaceImpl::getPeerAddress()
{
	AddressList::iterator it = _addressList.begin();
	AddressList::iterator end = _addressList.end();
	for (; it != end; ++it)
	{
		IPAddress::Family family = it->get<NetworkInterface::IP_ADDRESS>().family();
		DatagramSocket ds(family);
#if !defined(POCO_OS_FAMILY_WINDOWS) && !defined(POCO_VXWORKS)
		struct ifreq ifr;
		std::strncpy(ifr.ifr_name, _name.c_str(), IFNAMSIZ);
		ds.impl()->ioctl(SIOCGIFDSTADDR, &ifr);
		 // for PPP-type connections, broadcastAddress member holds the peer address
		if (ifr.ifr_dstaddr.sa_family == AF_INET)
			it->set<NetworkInterface::BROADCAST_ADDRESS>(IPAddress(ifr.ifr_dstaddr));
		else
			it->set<NetworkInterface::BROADCAST_ADDRESS>(IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(&ifr.ifr_dstaddr)->sin6_addr, sizeof(struct in6_addr), _index));
#else
			//TODO
#endif
	}
}


NetworkInterfaceImpl::~NetworkInterfaceImpl()
{
}


bool NetworkInterfaceImpl::supportsIPv4() const
{
	AddressList::const_iterator it = _addressList.begin();
	AddressList::const_iterator end = _addressList.end();
	for (; it != end; ++it)
	{
		if (IPAddress::IPv4 == it->get<NetworkInterface::IP_ADDRESS>().family())
			return true;
	}

	return false;
}


bool NetworkInterfaceImpl::supportsIPv6() const
{
	AddressList::const_iterator it = _addressList.begin();
	AddressList::const_iterator end = _addressList.end();
	for (; it != end; ++it)
	{
		if (IPAddress::IPv6 == it->get<NetworkInterface::IP_ADDRESS>().family())
			return true;
	}

	return false;
}


inline int NetworkInterfaceImpl::index() const
{
	return _index;
}


inline const std::string& NetworkInterfaceImpl::name() const
{
	return _name;
}


inline const std::string& NetworkInterfaceImpl::displayName() const
{
	return _displayName;
}


void NetworkInterfaceImpl::addAddress(const AddressTuple& address)
{
	_addressList.push_back(address);
}


bool NetworkInterfaceImpl::hasAddress(const IPAddress& address) const
{
	NetworkInterface::ConstAddressIterator it = _addressList.begin();
	NetworkInterface::ConstAddressIterator end = _addressList.end();
	for (; it != end; ++it)
	{
		if (it->get<NetworkInterface::IP_ADDRESS>() == address) 
			return true;
	}
	return false;
}


inline const IPAddress& NetworkInterfaceImpl::address(std::size_t index) const
{
	if (index < _addressList.size()) return _addressList[index].get<NetworkInterface::IP_ADDRESS>();
	else throw NotFoundException(Poco::format("No address with index %z.", index));
}


inline const NetworkInterface::AddressList& NetworkInterfaceImpl::addressList() const
{
	return _addressList;
}


inline const IPAddress& NetworkInterfaceImpl::subnetMask(std::size_t index) const
{
	if (index < _addressList.size()) 
		return _addressList[index].get<NetworkInterface::SUBNET_MASK>();

	throw NotFoundException(Poco::format("No subnet mask with index %z.", index));
}


inline const IPAddress& NetworkInterfaceImpl::broadcastAddress(std::size_t index) const
{
	if (index < _addressList.size()) 
		return _addressList[index].get<NetworkInterface::BROADCAST_ADDRESS>();

	throw NotFoundException(Poco::format("No subnet mask with index %z.", index));
}


inline const IPAddress& NetworkInterfaceImpl::destAddress(std::size_t index) const
{
	if (!pointToPoint()) 
		throw InvalidAccessException("Only PPP addresses have destination address.");
	else if (index < _addressList.size()) 
		return _addressList[index].get<NetworkInterface::BROADCAST_ADDRESS>();
	
	throw NotFoundException(Poco::format("No address with index %z.", index));
}


inline int NetworkInterfaceImpl::mtu() const
{
	return _mtu;
}


inline bool NetworkInterfaceImpl::broadcast() const
{
	return _broadcast;
}


inline bool NetworkInterfaceImpl::loopback() const
{
	return _loopback;
}


inline bool NetworkInterfaceImpl::multicast() const
{
	return _multicast;
}


inline bool NetworkInterfaceImpl::pointToPoint() const
{
	return _pointToPoint;
}


inline bool NetworkInterfaceImpl::running() const
{
	return _running;
}


inline bool NetworkInterfaceImpl::up() const
{
	return _up;
}


#if defined(POCO_OS_FAMILY_WINDOWS)

void NetworkInterfaceImpl::setFlags(DWORD flags, DWORD iftype)
{
	_running = _up = true;
	switch (iftype) {
	case IF_TYPE_ETHERNET_CSMACD:
	case IF_TYPE_ISO88025_TOKENRING:
	case IF_TYPE_IEEE80211:
		_multicast = _broadcast = true;
		break;
	case IF_TYPE_SOFTWARE_LOOPBACK:
		_loopback =  true;
		break;
	case IF_TYPE_PPP:
	case IF_TYPE_ATM:
	case IF_TYPE_TUNNEL:
	case IF_TYPE_IEEE1394:
		_pointToPoint = true;
		break;
	}
	if (!(flags & IP_ADAPTER_NO_MULTICAST))
		_multicast = true;
}

#else

void NetworkInterfaceImpl::setFlags(short flags)
{
#ifdef POCO_OS_FAMILY_UNIX
	_broadcast = ((flags & IFF_BROADCAST) != 0);
	_loopback = ((flags & IFF_LOOPBACK) != 0);
	_multicast = ((flags & IFF_MULTICAST) != 0);
	_pointToPoint = ((flags & IFF_POINTOPOINT) != 0);
	_running = ((flags & IFF_RUNNING) != 0);
	_up = ((flags & IFF_UP) != 0);
#endif
}

#endif


inline void NetworkInterfaceImpl::setUp(bool up)
{
	_up = up;
}


inline void NetworkInterfaceImpl::setMtu(int mtu)
{
	_mtu = mtu;
}


inline void NetworkInterfaceImpl::setIndex(unsigned index)
{
	_index = index;
}


inline void NetworkInterfaceImpl::setName(const std::string& name)
{
	_name = name;
}


inline void NetworkInterfaceImpl::setDisplayName(const std::string& name)
{
	_displayName = name;
}


inline void NetworkInterfaceImpl::addAddress(const IPAddress& addr)
{
	_addressList.push_back(addr);
}


//
// NetworkInterface
//


FastMutex NetworkInterface::_mutex;


NetworkInterface::NetworkInterface(std::size_t index):
	_pImpl(new NetworkInterfaceImpl(index))
{
}


NetworkInterface::NetworkInterface(const NetworkInterface& interfc):
	_pImpl(interfc._pImpl)
{
	_pImpl->duplicate();
}


NetworkInterface::NetworkInterface(const std::string& name, const std::string& displayName, const IPAddress& address, int index):
	_pImpl(new NetworkInterfaceImpl(name, displayName, address, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const std::string& displayName, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_pImpl(new NetworkInterfaceImpl(name, displayName, address, subnetMask, broadcastAddress, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const IPAddress& address, int index):
	_pImpl(new NetworkInterfaceImpl(name, name, address, index))
{
}


NetworkInterface::NetworkInterface(const std::string& name, const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress, int index):
	_pImpl(new NetworkInterfaceImpl(name, name, address, subnetMask, broadcastAddress, index))
{
}


NetworkInterface::~NetworkInterface()
{
	_pImpl->release();
}


NetworkInterface& NetworkInterface::operator = (const NetworkInterface& interfc)
{
	NetworkInterface tmp(interfc);
	swap(tmp);
	return *this;
}


void NetworkInterface::swap(NetworkInterface& other)
{
	using std::swap;
	swap(_pImpl, other._pImpl);
}


std::size_t NetworkInterface::index() const
{
	return _pImpl->index();
}


const std::string& NetworkInterface::name() const
{
	return _pImpl->name();
}


const std::string& NetworkInterface::displayName() const
{
	return _pImpl->displayName();
}


void NetworkInterface::addAddress(const IPAddress& address)
{
	_pImpl->addAddress(AddressTuple(address, IPAddress(), IPAddress()));
}


void NetworkInterface::addAddress(const IPAddress& address, const IPAddress& subnetMask, const IPAddress& broadcastAddress)
{
	_pImpl->addAddress(AddressTuple(address, subnetMask, broadcastAddress));
}


const IPAddress& NetworkInterface::address(std::size_t index) const
{
	return _pImpl->address(index);
}


const NetworkInterface::AddressList& NetworkInterface::addressList() const
{
	return _pImpl->addressList();
}


const IPAddress& NetworkInterface::subnetMask(std::size_t index) const
{
	return _pImpl->subnetMask(index);
}


const IPAddress& NetworkInterface::broadcastAddress(std::size_t index) const
{
	return _pImpl->broadcastAddress(index);
}


const IPAddress& NetworkInterface::destAddress(std::size_t index) const
{
	return _pImpl->destAddress(index);
}


int NetworkInterface::mtu() const
{
	return _pImpl->mtu();
}


bool NetworkInterface::supportsIPv4() const
{
	return _pImpl->supportsIPv4();
}

	
bool NetworkInterface::supportsIPv6() const
{
	return _pImpl->supportsIPv6();
}


bool NetworkInterface::supportsBroadcast() const
{
	return _pImpl->broadcast();
}

bool NetworkInterface::supportsMulticast() const
{
	return _pImpl->multicast();
}

bool NetworkInterface::isLoopback() const
{
	return _pImpl->loopback();
}

bool NetworkInterface::isPointToPoint() const
{
	return _pImpl->pointToPoint();
}

bool NetworkInterface::isRunning() const
{
	return _pImpl->running();
}

bool NetworkInterface::isUp() const
{
	return _pImpl->up();
}


NetworkInterface NetworkInterface::forName(const std::string& name, bool requireIPv6)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->name() == name && ((requireIPv6 && it->supportsIPv6()) || !requireIPv6))
			return *it;
	}
	throw InterfaceNotFoundException(name);
}


NetworkInterface NetworkInterface::forName(const std::string& name, IPVersion ipVersion)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->name() == name)
		{
			if (ipVersion == IPv4_ONLY && it->supportsIPv4())
				return *it;
			else if (ipVersion == IPv6_ONLY && it->supportsIPv6())
				return *it;
			else if (ipVersion == IPv4_OR_IPv6)
				return *it;
		}
	}
	throw InterfaceNotFoundException(name);
}

	
NetworkInterface NetworkInterface::forAddress(const IPAddress& addr)
{
	NetworkInterfaceList ifs = list();
	for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
	{
		if (it->address() == addr)
			return *it;
	}
	throw InterfaceNotFoundException(addr.toString());
}


NetworkInterface NetworkInterface::forIndex(int i)
{
	if (i != 0)
	{
		NetworkInterfaceList ifs = list();
		for (NetworkInterfaceList::const_iterator it = ifs.begin(); it != ifs.end(); ++it)
		{
			if (it->index() == i)
				return *it;
		}
		throw InterfaceNotFoundException("#" + NumberFormatter::format(i));
	}
	else return NetworkInterface();
}


NetworkInterface::List NetworkInterface::list()
{
	List list;
	Map m = map();

	for (NetworkInterface::Map::const_iterator it = m.begin(); it != m.end(); ++it)
	{
		int index = it->second.index();
		std::string name = it->second.name();
		std::string displayName = it->second.displayName();

		typedef NetworkInterface::AddressList List;
		const List& ipList = it->second.addressList();
		List::const_iterator ipIt = ipList.begin();
		List::const_iterator ipEnd = ipList.end();
		for (int counter = 0; ipIt != ipEnd; ++ipIt, ++counter)
		{
			IPAddress addr = ipIt->get<NetworkInterface::IP_ADDRESS>();
			IPAddress mask = ipIt->get<NetworkInterface::SUBNET_MASK>();
			NetworkInterface ni;
			if (mask.isWildcard())
				ni = NetworkInterface(name, displayName, addr, index);
			else
			{
				IPAddress broadcast = ipIt->get<NetworkInterface::BROADCAST_ADDRESS>();
				ni = NetworkInterface(name, displayName, addr, mask, broadcast, index);
			}

			list.push_back(ni);
		}
	}
	
	return list;
}


} } // namespace Poco::Net


//
// platform-specific code below
//


#if defined(POCO_OS_FAMILY_WINDOWS)
//
// Windows
//


#include "Poco/Buffer.h"
#include <iterator>


namespace Poco {
namespace Net {

NetworkInterface::Map NetworkInterface::map()
{
	FastMutex::ScopedLock lock(_mutex);
	Map result;
	ULONG outBufLen = 16384;
	Poco::Buffer<UCHAR> memory(outBufLen);
	ULONG flags = (GAA_FLAG_SKIP_ANYCAST | GAA_FLAG_SKIP_MULTICAST | GAA_FLAG_SKIP_DNS_SERVER | GAA_FLAG_INCLUDE_PREFIX);
#if defined(POCO_HAVE_IPv6)
	const unsigned family = AF_UNSPEC; //IPv4 and IPv6
#else
	const unsigned family = AF_INET; //IPv4 only
#endif
	DWORD dwRetVal = 0;
	ULONG iterations = 0;
	PIP_ADAPTER_ADDRESSES pAddresses = reinterpret_cast<IP_ADAPTER_ADDRESSES*>(memory.begin());
	do
	{
		if ((dwRetVal = GetAdaptersAddresses(family, flags, NULL, pAddresses, &outBufLen)) == ERROR_BUFFER_OVERFLOW)
			memory.resize(outBufLen);
		else break;
	} while ((dwRetVal == ERROR_BUFFER_OVERFLOW) && (++iterations <= 2));

	if (dwRetVal == ERROR_NO_DATA) return result;// no network interfaces found

	if (dwRetVal == NO_ERROR)
	{
		for (PIP_ADAPTER_ADDRESSES pAddress = pAddresses; pAddress; pAddress = pAddress->Next)
		{
			IPAddress address;
			IPAddress subnetMask;
			IPAddress broadcastAddress;
			IPAddress destAddress;
			unsigned ifIndex = ~0;
			
#if defined(POCO_HAVE_IPv6)
			if (pAddress->Flags & IP_ADAPTER_IPV6_ENABLED) ifIndex = pAddress->Ipv6IfIndex;
			else
#endif
			if (pAddress->Flags & IP_ADAPTER_IPV4_ENABLED) ifIndex = pAddress->IfIndex;

			PIP_ADAPTER_PREFIX pPrefix = pAddress->FirstPrefix;
			for (PIP_ADAPTER_UNICAST_ADDRESS pUniAddr = pAddress->FirstUnicastAddress; 
				pUniAddr; 
				pUniAddr = pUniAddr->Next, pPrefix = pPrefix ? pPrefix->Next : 0)
			{
				std::string name(pAddress->AdapterName);
				std::string displayName;
#ifdef POCO_WIN32_UTF8
				Poco::UnicodeConverter::toUTF8(pAddress->FriendlyName, displayName);
#else
				char displayNameBuffer[1024];
				int rc = WideCharToMultiByte(CP_ACP, WC_DEFAULTCHAR, pAddress->FriendlyName, -1, displayNameBuffer, sizeof(displayNameBuffer), NULL, NULL);
				if (rc) displayName = displayNameBuffer;
#endif
				address = IPAddress(pUniAddr->Address);
				ADDRESS_FAMILY family = pUniAddr->Address.lpSockaddr->sa_family;
				Map::iterator ifIt = result.find(ifIndex);
				switch (family)
				{
					case AF_INET:
					{
						bool hasBroadcast = (pAddress->IfType == IF_TYPE_ETHERNET_CSMACD);
						subnetMask = pPrefix ? IPAddress(pPrefix->Length, IPAddress::IPv4) : IPAddress();
						broadcastAddress = address | ~subnetMask;
						if (ifIt == result.end()) 
						{
							if (hasBroadcast)
								ifIt = result.insert(Map::value_type(ifIndex, NetworkInterface(name, displayName, address, subnetMask, broadcastAddress, ifIndex))).first;
							else
								ifIt = result.insert(Map::value_type(ifIndex, NetworkInterface(name, displayName, address, ifIndex))).first;
						}
						else
						{
							if (hasBroadcast)
								ifIt->second.addAddress(address, subnetMask, broadcastAddress);
							else
								ifIt->second.addAddress(address);
						}
					} break;
#if defined(POCO_HAVE_IPv6)
					case AF_INET6:
					{
						if (ifIt == result.end()) ifIt = result.insert(Map::value_type(ifIndex, NetworkInterface(name, displayName, address, ifIndex))).first;
						else
							ifIt->second.addAddress(address);
					} break;
#endif
				} // switch family
					ifIt->second.impl().setFlags(pAddress->Flags, pAddress->IfType);
					ifIt->second.impl().setMtu(pAddress->Mtu);
					ifIt->second.impl().setUp(pAddress->OperStatus == IfOperStatusUp);
			} // for addresses
		} // for adapters
	} // if no error
	else // error occurred
	{
		std::string errMsg;
		DWORD dwFlg = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS;
#if defined(POCO_WIN32_UTF8) && !defined(POCO_NO_WSTRING)
		LPWSTR lpMsgBuf = 0;
		if (FormatMessageW(dwFlg, 0, dwRetVal, 0, (LPWSTR) & lpMsgBuf, 0, NULL))
		{
			UnicodeConverter::toUTF8(lpMsgBuf, errMsg);
			LocalFree(lpMsgBuf);
		}
#else
		LPTSTR lpMsgBuf = 0;
		if (FormatMessageA(dwFlg, 0, dwRetVal, 0, (LPTSTR) & lpMsgBuf, 0, NULL))
		{
			errMsg = lpMsgBuf;
			LocalFree(lpMsgBuf);
		}
#endif
		
		throw SystemException(format("An error occurred whiel trying to obtain list of network interfaces: [%s]", errMsg));
	}

	return result;
}


} } // namespace Poco::Net


#elif defined(POCO_VXWORKS)
//
// VxWorks
//


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;

	int ifIndex = 1;
	char ifName[32];
	char ifAddr[INET_ADDR_LEN];

	for (;;)
	{
		if (ifIndexToIfName(ifIndex, ifName) == OK)
		{
			std::string name(ifName);
			IPAddress addr;
			IPAddress mask;
			IPAddress bcst;
			if (ifAddrGet(ifName, ifAddr) == OK)
			{			
				addr = IPAddress(std::string(ifAddr));
			}
			int ifMask;
			if (ifMaskGet(ifName, &ifMask) == OK)
			{
				mask = IPAddress(&ifMask, sizeof(ifMask));
			}
			if (ifBroadcastGet(ifName, ifAddr) == OK)
			{
				bcst = IPAddress(std::string(ifAddr));
			}
			result.push_back(NetworkInterface(name, name, addr, mask, bcst));
			ifIndex++;
		}
		else break;	
	}

	return result;
}


} } // namespace Poco::Net


#elif defined(POCO_OS_FAMILY_BSD) || POCO_OS == POCO_OS_QNX
//
// BSD variants
//
#include <sys/types.h>
#include <sys/socket.h>
#include <ifaddrs.h>
#include <net/if_dl.h>


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;

	struct ifaddrs* ifaphead;
	int rc = getifaddrs(&ifaphead);
	if (rc) throw NetException("cannot get network adapter list");

	for (struct ifaddrs* ifap = ifaphead; ifap; ifap = ifap->ifa_next) 
	{
		if (ifap->ifa_addr)
		{
			if (ifap->ifa_addr->sa_family == AF_INET)
			{
				std::string name(ifap->ifa_name);
				IPAddress addr(*(ifap->ifa_addr));
				IPAddress subnetMask, broadcastAddr;
				if (ifap->ifa_netmask)
					subnetMask = IPAddress(*(ifap->ifa_netmask));
				if ((ifap->ifa_flags & IFF_BROADCAST)
				  && ifap->ifa_broadaddr)
					broadcastAddr = IPAddress(*(ifap->ifa_broadaddr));
				result.push_back(NetworkInterface(name, name, addr, subnetMask, broadcastAddr));
			}
#if defined(POCO_HAVE_IPv6)
			else if (ifap->ifa_addr->sa_family == AF_INET6)
			{
				std::string name(ifap->ifa_name);
				Poco::UInt32 ifIndex = if_nametoindex(ifap->ifa_name);
				IPAddress addr(&reinterpret_cast<struct sockaddr_in6*>(ifap->ifa_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
				IPAddress subnetMask, broadcastAddr;
				if (ifap->ifa_netmask)
					subnetMask = IPAddress(*(ifap->ifa_netmask));
				if ((ifap->ifa_flags & IFF_BROADCAST)
				  && ifap->ifa_broadaddr)
					broadcastAddr = IPAddress(*(ifap->ifa_broadaddr));
				result.push_back(NetworkInterface(name, name, addr, subnetMask, broadcastAddr, ifIndex));
			}
#endif
		}
	}
	freeifaddrs(ifaphead);
	return result;
}


} } // namespace Poco::Net


#elif POCO_OS == POCO_OS_LINUX
//
// Linux
//
#if defined(POCO_HAVE_IPv6)


#include <sys/types.h>
#include <ifaddrs.h>


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	NetworkInterfaceList result;

	struct ifaddrs* ifaces = 0;
	struct ifaddrs* currIface = 0;

	if (getifaddrs(&ifaces) < 0) 
		throw NetException("cannot get network adapter list");
	
	try 
	{
		for (currIface = ifaces; currIface != 0; currIface = currIface->ifa_next) 
		{
			IPAddress addr;
			bool haveAddr = false;
			int ifIndex(-1);
			if (currIface->ifa_addr)
			{
				switch (currIface->ifa_addr->sa_family)
				{
				case AF_INET6:
					ifIndex = if_nametoindex(currIface->ifa_name);
					addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(currIface->ifa_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
					haveAddr = true;
					break;
				case AF_INET:
					addr = IPAddress(*(currIface->ifa_addr));
					haveAddr = true;
					break;
				default:
					break;
				}
			}
			if (haveAddr) 
			{
				std::string name(currIface->ifa_name);
				result.push_back(NetworkInterface(name, name, addr, ifIndex));
			}
		}
	}
	catch (...) 
	{
	}
	if (ifaces) freeifaddrs(ifaces);

	return result;
}


} } // namespace Poco::Net


#else // !POCO_HAVE_IPv6


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;
	DatagramSocket socket;
	// the following code is loosely based
	// on W. Richard Stevens, UNIX Network Programming, pp 434ff.
	int lastlen = 0;
	int len = 100*sizeof(struct ifreq);
	char* buf = 0;
	try
	{
		struct ifconf ifc;
		for (;;)
		{
			buf = new char[len];
			ifc.ifc_len = len;
			ifc.ifc_buf = buf;
			if (::ioctl(socket.impl()->sockfd(), SIOCGIFCONF, &ifc) < 0)
			{
				if (errno != EINVAL || lastlen != 0)
					throw NetException("cannot get network adapter list");
			}
			else
			{
				if (ifc.ifc_len == lastlen)
					break;
				lastlen = ifc.ifc_len;
			}
			len += 10*sizeof(struct ifreq);
			delete [] buf;
		}
		for (const char* ptr = buf; ptr < buf + ifc.ifc_len;)
		{
			const struct ifreq* ifr = reinterpret_cast<const struct ifreq*>(ptr);
			IPAddress addr;
			bool haveAddr = false;
			switch (ifr->ifr_addr.sa_family)
			{
			case AF_INET:
				addr = IPAddress(ifr->ifr_addr);
				haveAddr = true;
				break;
			default:
				break;
			}
			if (haveAddr)
			{
				int index = -1;
				std::string name(ifr->ifr_name);
				result.push_back(NetworkInterface(name, name, addr, index));
			}
			ptr += sizeof(struct ifreq);
		}
	}
	catch (...)
	{
		delete [] buf;
		throw;
	}
	delete [] buf;
	return result;
}


} } // namespace Poco::Net


#endif // POCO_HAVE_IPv6


#else
//
// Non-BSD Unix variants
//


namespace Poco {
namespace Net {


NetworkInterface::NetworkInterfaceList NetworkInterface::list()
{
	FastMutex::ScopedLock lock(_mutex);
	NetworkInterfaceList result;
	DatagramSocket socket;
	// the following code is loosely based
	// on W. Richard Stevens, UNIX Network Programming, pp 434ff.
	int lastlen = 0;
	int len = 100*sizeof(struct ifreq);
	char* buf = 0;
	try
	{
		struct ifconf ifc;
		for (;;)
		{
			buf = new char[len];
			ifc.ifc_len = len;
			ifc.ifc_buf = buf;
			if (::ioctl(socket.impl()->sockfd(), SIOCGIFCONF, &ifc) < 0)
			{
				if (errno != EINVAL || lastlen != 0)
					throw NetException("cannot get network adapter list");
			}
			else
			{
				if (ifc.ifc_len == lastlen)
					break;
				lastlen = ifc.ifc_len;
			}
			len += 10*sizeof(struct ifreq);
			delete [] buf;
		}
		for (const char* ptr = buf; ptr < buf + ifc.ifc_len;)
		{
			const struct ifreq* ifr = reinterpret_cast<const struct ifreq*>(ptr);
#if defined(POCO_HAVE_SALEN)
			len = ifr->ifr_addr.sa_len;
			if (sizeof(struct sockaddr) > len) len = sizeof(struct sockaddr);
#else
			len = sizeof(struct sockaddr);
#endif
			IPAddress addr;
			bool haveAddr = false;
			int ifIndex(-1);
			switch (ifr->ifr_addr.sa_family)
			{
#if defined(POCO_HAVE_IPv6)
			case AF_INET6:
				ifIndex = if_nametoindex(ifr->ifr_name);
				if (len < sizeof(struct sockaddr_in6)) len = sizeof(struct sockaddr_in6);
				addr = IPAddress(&reinterpret_cast<const struct sockaddr_in6*>(&ifr->ifr_addr)->sin6_addr, sizeof(struct in6_addr), ifIndex);
				haveAddr = true;
				break;
#endif
			case AF_INET:
				if (len < sizeof(struct sockaddr_in)) len = sizeof(struct sockaddr_in);
				addr = IPAddress(ifr->ifr_addr);
				haveAddr = true;
				break;
			default:
				break;
			}
			if (haveAddr)
			{
				std::string name(ifr->ifr_name);
				result.push_back(NetworkInterface(name, name, addr, ifIndex));
			}
			len += sizeof(ifr->ifr_name);
			ptr += len;
		}
	}
	catch (...)
	{
		delete [] buf;
		throw;
	}
	delete [] buf;
	return result;
}


} } // namespace Poco::Net


#endif
